# JavaScript_Interview_Questions

<p style="font-size: 18px">Junior</p>
<ul>
  <li><a href="#junior">Junior/Загальні</a></li>
  <li><a href="#js-core">Junior/JS-Core</a></li>
  <li><a href="#функції">Junior/Функції</a></li>
  <li><a href="#front-end">Junior/Front-end</a></li>
  <li><a href="#react">Junior/React</a></li>
  <li><a href="#back-end">Junior/Back-end</a></li>
  <li><a href="#бази-даних">Junior/Бази даних</a></li>
</ul>

<p style="font-size: 18px">Middle</p>
<ul>
  <li><a href="#middle">Middle/Загальні</a></li>
  <li><a href="#js-core">Middle/JS-Core</a></li>
  <li><a href="#функції">Middle/Функції</a></li>
  <li><a href="#front-end">Middle/Front-end</a></li>
  <li><a href="#react">Middle/React</a></li>
  <li><a href="#back-end">Middle/Back-end</a></li>
  <li><a href="#бази-даних">Middle/Бази даних</a></li>
</ul>


## Junior
### Загальні
1. Які методи HTTP-запитів ви знаєте? 
- HTTP (Hypertext Transfer Protocol) має кілька методів запитів, основні з них:
  * GET: Використовується для отримання даних з сервера.
  * POST: Використовується для надсилання даних на сервер для створення нового ресурсу.
  * PUT: Використовується для оновлення існуючого ресурсу на сервері.
  * DELETE: Використовується для видалення ресурсу на сервері.
  * HEAD: Схожий на GET, але повертає лише заголовки без тіла відповіді.
  * OPTIONS: Використовується для отримання інформації про можливі методи та параметри ресурсу.

2. Які версії HTTP-протоколу вам відомі?
- HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3
- HTTP/2 і HTTP/3 призначені для покращення швидкості завантаження веб-сайтів і зменшення затрат на передачу даних порівняно з HTTP/1.0 і HTTP/1.1.
3. Які знаєте коди відповіді (стану) HTTP?
- 200 OK: Успішний запит.
- 201 Created: Ресурс успішно створений.
- 204 No Content: Запит виконаний, але немає даних для передачі.
- 400 Bad Request: Помилка у запиті від клієнта.
- 401 Unauthorized: Вимагається автентифікація для доступу.
- 403 Forbidden: Доступ заборонено через обмеження сервера.
- 404 Not Found: Ресурс не знайдено.
- 500 Internal Server Error: Внутрішня помилка сервера.
4. Що таке Cross-Origin Resource Sharing? Як усунути проблеми з CORS?
- Cross-Origin Resource Sharing (CORS) - це механізм безпеки в браузерах, який контролює доступ клієнта до ресурсів на іншому домені (орієнтований на джерело). Щоб усунути проблеми з CORS, потрібно налаштувати сервер для дозволу запитів з інших доменів, встановити заголовки Access-Control-Allow-Origin, Access-Control-Allow-Methods, тощо.
5. Що таке cookie?
- Cookie - це невеликий фрагмент даних, який сервер відправляє на браузер користувача, і браузер зберігає його та включає в кожен наступний запит до сервера. Вони використовуються для збереження інформації про сесію, налаштування і інші дані на боці клієнта.
6. Який максимальний розмір cookie?
- Максимальний розмір cookie обмежений браузером, зазвичай це близько 4096 байтів на кожний cookie, але це може варіюватися в залежності від браузера.
7. Що означає директива use strict?
8. Чим JS відрізняється під час роботи на front-end і back-end?
 - JavaScript на фронтенді (в браузері) використовується для взаємодії з користувачем і маніпуляції вмістом сторінки. На бекенді (на стороні сервера), JavaScript може використовуватися для розробки серверних додатків, обробки запитів, зберігання даних, тощо.
9. Що таке статична і динамічна типізації?
 - Статична типізація передбачає, що типи змінних визначаються під час компіляції і не можуть змінюватися під час виконання. Динамічна типізація дозволяє змінювати типи змінних під час виконання програми.
10. Як клієнт взаємодіє із сервером?
 - Клієнт взаємодіє з сервером, відправляючи HTTP-запити (наприклад, GET або POST) і отримуючи HTTP-відповіді. Взаємодія може включати передачу даних, завантаження сторінок, виконання запитів API, отримання ресурсів і багато іншого.
11. Що таке REST?
 - REST (Representational State Transfer) - це архітектурний стиль для розробки веб-сервісів, який використовує HTTP-методи (GET, POST, PUT, DELETE) для взаємодії з ресурсами через їхні URI. REST вимагає, щоб взаємодія була безстанційною і зберігала стан серверу на стороні клієнта.
12. Поясніть поняття мутабельність / іммутабельність? Які типи є мутабельними й навпаки?
 - Мутабельність вказує на можливість зміни об'єктів після їхньої створення, тоді як іммутабельність вказує на незмінність об'єктів після створення. У JavaScript, наприклад, рядки є іммутабельними, а масиви - мутабельними.
13. Як шукати помилки в коді? Чи використовуєте дебагер?
 -  Пошук помилок в коді можна проводити шляхом відстеження помилкових повідомлень, використання відлагоджувачів (debugger) для аналізу стану програми в точці зупинки, а також використання інструментів розробки браузера, таких як консоль для відлагодження. Важливо також тестувати код і використовувати тести для виявлення помилок.
14. Яких відомих людей зі світу JS знаєте?
 - Brendan Eich: Створив JavaScript.
 - Douglas Crockford: Відомий експерт з JavaScript і автор "JavaScript: The Good Parts."
 - John Resig: Розробив бібліотеку jQuery.
 - Ryan Dahl: Створив платформу Node.js.
 - Kyle Simpson: Автор серії книг "You Don't Know JS".

### JS Core
15. Які існують типи даних у JS?
- Примітивні типи: Number, String, Boolean, Null, Undefined, Symbol (ES6), BigInt (ES11).
- Об'єктні типи: Object, Array, Function, Date, RegExp, інші користувацькі об'єкти.
16. Як перевірити, чи об’єкт є масивом?
- Для перевірки, чи об'єкт є масивом, використовуйте метод Array.isArray(obj).
17. Як перевірити, чи число є скінченним?
- Щоб перевірити, чи число є скінченним, використовуйте isFinite(number).
18. Як перевірити, що змінна рівна NaN?
- Перевірку на NaN можна здійснити за допомогою isNaN(value).
19. Чим відрізняється поведінка isNaN() та Number.isNaN()?
- isNaN() перетворює аргумент в число перед перевіркою, тому може давати неправильний результат для нечислових значень, а Number.isNaN() перевіряє точно, чи значення є NaN.
20. Порівняйте ключові слова var, let, const.
- var - має функціональну область видимості і може бути змінено після оголошення;
- let - обмежена блоковою областю видимості і може бути змінено;
- const - обмежена блоковою областю видимості і не може бути переприсвоєна, але об'єкти, на які вона посилається, можуть змінюватися.
21. Що таке область видимості?
- Область видимості - це частина коду, де змінні або функції доступні для використання. В JavaScript області видимості визначаються за допомогою блоків коду, функцій і об'єктів.
22. Що таке деструктуризація?
- Деструктуризація - це спосіб отримання окремих значень з об'єкта або масиву і присвоєння їх змінним, за допомогою синтаксису, схожого на внесення.
23. Для чого призначені методи setTimeout і setInterval?
- setTimeout використовується для виконання функції після зазначеного проміжку часу, а setInterval - для виконання функції через регулярні інтервали часу.
24. Порівняйте підходи роботи з асинхронним кодом: сallbacks vs promises vs async/await.
- Колбеки (Callbacks):
  1. Це стандартний спосіб обробки асинхронності в JavaScript до появи більш сучасних підходів.
  2. Колбеки - це функції, які передаються як аргументи і викликаються після завершення асинхронної операції.
  3. Може виникнути "callback hell", коли багато асинхронних операцій вкладені одна в одну, що робить код важким для розуміння та обслуговування.

- Promises:
  1. Promises вводять концепцію об'єкта Promise, який представляє результат асинхронної операції, яка може бути успішною або невдалим.
  2. Це полегшує читання та обробку асинхронного коду і дозволяє уникнути "callback hell".
  3. Promise може бути в стані "виконано" (resolved) або "відхилено" (rejected), і можна приєднувати колбеки для обробки кожного з цих станів.

- async/await:
  1. async/await - це синтаксичний цукор над promises, який робить асинхронний код більш читабельним і схожим на синхронний код.
  2. async визначає функцію, яка повертає promises автоматично.
  3. await використовується в середині функції async для очікування завершення promises та повернення її результату.

25. Чи можна записувати нові властивості / функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?
- Так, можна записувати нові властивості / методи в прототипи стандартних класів. Проте це рекомендується робити обережно, оскільки це може призвести до конфліктів і непередбачених наслідків. Краще використовувати об'єкт, який наслідує від стандартного класу, і додавати властивості / методи до нього.
26. Назвіть методи масивів, які пам’ятаєте, і скажіть, для чого вони потрібні.
- push(): Додає елемент на кінець масиву.
- pop(): Видаляє останній елемент з масиву.
- shift(): Видаляє перший елемент з масиву.
- unshift(): Додає елемент на початок масиву.
- concat(): Об'єднує два масиви в новий масив.
- slice(): Повертає підмасив на основі вказаних індексів.
- forEach(): Виконує функцію для кожного елемента масиву.
- map(): Створює новий масив на основі результатів функції для кожного елемента.
- filter(): Створює новий масив, який містить елементи, які задовольняють умову.
- reduce(): Зменшує масив до одного значення за допомогою функції.
27. Які перебираючі методи масиву знаєте? У чому їхня відмінність?
 - forEach(): Виконує функцію для кожного елемента, не створюючи нового масиву.
 - map(): Створює новий масив, застосовуючи функцію до кожного елемента.
 - filter(): Створює новий масив з елементами, які відповідають умові.
 - reduce(): Обчислює одне значення за допомогою функції, яка накопичує результати обробки елементів масиву.
 - every(): Перевіряє, чи всі елементи масиву відповідають заданій умові і повертає булеве значення (true або false).
 - some(): Перевіряє, чи хоча б один елемент масиву відповідає заданій умові і повертає булеве значення (true або false).
 - find(): Знаходить перший елемент, який відповідає заданій умові.

findIndex(): Знаходить індекс першого елемента, який відповідає заданій умові.
28. Як працюють оператори присвоєння / порівняння / рядкові / арифметичні / бітові тощо?
- Оператори присвоєння (=, +=, -= тощо) встановлюють значення змінних.
- Оператори порівняння (==, ===, !=, !==, <, >, <=, >=) порівнюють значення.
- Оператори рядкові (+ для об'єднання рядків) виконують операції з рядками.
- Оператори арифметичні (+, -, *, /, %) виконують математичні операції.
- Оператори бітові (&, |, ^, <<, >>) працюють з бітами чисел.
29. Опишіть призначення і принципи роботи з колекціями Map і Set.
- Map - це колекція ключ-значення, де ключі можуть бути будь-якого типу, а Set - це колекція унікальних значень без повторень. Map і Set забезпечують швидкий доступ до даних і можуть використовуватися для зберігання та управління даними.
30. Що означає глибока (deep) та поверхнева (shallow) копія об’єкта? Як зробити кожну з них?
- Глибока копія об'єкта створює новий об'єкт, який копіює всі значення об'єкта та всі значення вкладених об'єктів та масивів, рекурсивно. Поверхнева копія створює новий об'єкт, але посилається на ті ж самі вкладені об'єкти та масиви. Глибоку копію можна створити рекурсивно, обходячи об'єкт і копіюючи його вміст, а поверхневу копію можна створити за допомогою Object.assign() або оператора деструктуризації.

### Функції
31. Яка різниця між декларацією функції (function declaration) та функціональним виразом (function expression)?
- Декларація функції (function declaration) оголошує функцію з іменем, яка може бути викликана до її оголошення. Її оголошення піднімається вгору (hoisted).
  ```
  function add(a, b) {
  return a + b;
  }
  ```

- Функціональний вираз (function expression) створює функцію, присвоюючи її змінній або виразу. Функцію можна викликати тільки після її оголошення.

    ```
  const add = function(a, b) {
   return a + b;
  };
  ```
32. Що таке анонімна функція?
 - Анонімна функція - це функція без імені. Вона може бути оголошена як функція-вираз, і її можна викликати за допомогою змінної, до якої вона присвоєна.

33. Розкажіть про стрілкові функції (arrow function). В чому полягають відмінності стрілкових функцій від звичайних?
- Стрілкові функції (arrow functions) - це спрощений синтаксис для оголошення функцій у JavaScript.
- Основні відмінності:
  1. Стрілкові функції не мають власного контексту (this) і беруть його з оточуючого коду.
  2. Вони коротші та зручніші для написання.
34. Що таке і для чого використовують IIFE (Immediately Invoked Function Expression)?
- IIFE (Immediately Invoked Function Expression) - це функціональний вираз, який виконується негайно після оголошення. Вони зазвичай використовуються для створення локального області видимості для змінних і уникнення конфлікту імен.
```
(function() {
  // Код тут
})();

```
35. Що таке hoisting, як він працює для змінних і функцій?
- Hoisting - це механізм в JavaScript, за допомогою якого оголошення змінних і функцій піднімаються вгору до початку виконання коду. Змінні можуть бути оголошені після використання, але функції можуть бути викликані перед їхнім оголошенням.
36. Що таке замикання (closure) і які сценарії його використання?
- Замикання (closure) - це функція, яка має доступ до змінних зі свого зовнішнього лексичного середовища, навіть після завершення виконання цього середовища. Замикання дозволяє зберігати стан і інкапсулювати логіку.
37. Як ви розумієте замикання? Що буде виведено в консолі в цьому випадку?
  ```
   var f = function() {
     console.log(1);
   }

    var execute = function(f) {
      setTimeout(f, 1000);
    }

    execute(f);

     f = function() {
      console.log(2);
    }
  ```
  
- В замиканні функція "замикана" на своєму лексичному середовищі, і вона може звертатися до змінних, які були доступні в момент її створення.
- В консолі 1

38. Що таке рекурсія?
- Рекурсія - це техніка програмування, коли функція викликає сама себе для розв'язання певної задачі. Рекурсія може бути простою (рекурсивні виклики функції) або складною (рекурсивні виклики функції з умовами виходу). Вона часто використовується для розв'язання завдань, які можуть бути поділені на більше простих підзадач.
39. Що означає ключове слово this?
- Ключове слово this - це спеціальна змінна в контексті функції, яка вказує на об'єкт, з яким викликана функція пов'язана. this може змінюватися залежно від того, як функція викликана: як метод об'єкта, як глобальна функція тощо.
40. Що таке втрата контексту, коли відбувається і як їй запобігти?
- Втрата контексту відбувається, коли функція втрачає посилання на об'єкт, з яким вона пов'язана. Це може статися при передачі функції як колбека, використанні setTimeout, а також при використанні функцій в обробниках подій чи внутрішніх функціях.
41. Методи функцій bind / call / apply — навіщо і в чому різниця?
 - bind(): Створює нову функцію, де this завжди вказує на певний об'єкт, але не викликає функцію негайно. Замість цього повертає функцію, яку можна викликати пізніше.
   ```
     const boundFunc = originalFunc.bind(context);
    ```
  - call(): Викликає функцію з певним значенням this і переданими окремо аргументами.
    ```
      originalFunc.call(context, arg1, arg2, ...);
    ```
  - apply(): Схожий на call, але аргументи передаються у вигляді масиву.
    ```
     originalFunc.apply(context, [arg1, arg2, ...]);
    ```
### Front-end
42. Що таке DOM?
- DOM (Document Object Model) - це структура, яка представляє інтерактивний документ веб-сторінки, яка може бути змінена за допомогою JavaScript. Вона створює ієрархію об'єктів, які представляють кожен елемент HTML-сторінки, що дозволяє програмно взаємодіяти з цими елементами.
43. Порівняйте атрибути підключення скрипту async і defer в HTML-документі.
- async: Скрипт завантажується асинхронно, і виконується, як тільки завантажиться, незалежно від того, як завантажується решта сторінки.
- defer: Скрипт завантажується асинхронно, але виконується тільки після завантаження сторінки. Порядок виконання скриптів зберігається.
44. Яка різниця між властивостями HTML-елементів innerHTML і innerText?
- innerHTML: Зчитує або встановлює HTML-код вмісту елемента, включаючи теги.
- innerText: Зчитує або встановлює тільки текстовий вміст елемента, ігноруючи HTML-теги.
45. Опишіть процес спливання (bubbling) подій у DOM.
- Спливання (bubbling) подій у DOM - це процес, коли подія, спочатку спрацювавши на найглибшому вкладеному елементі, поширюється вгору по ієрархії батьківських елементів до кореня документа (body або html). Це дозволяє обробникам подій батьківських елементів реагувати на ту саму подію.
46. Як зупинити спливання (bubbling) події?
- Метод stopPropagation() може бути використаний в обробнику події для зупинки подальшого спливання події до вищих елементів.
47. Як зупинити дефолтну обробку події?
- Метод preventDefault() може бути використаний в обробнику події для зупинки стандартної дії, яка пов'язана з цією подією. Наприклад, відмінити перехід за посиланням в <a>.
48.Чому дорівнює this в обробнику подій (event handler)?
- this в обробнику подій (event handler) - це посилання на об'єкт, до якого відноситься обробник події, тобто на елемент DOM, до якого прикріплений цей обробник. Він може бути корисним для доступу до контексту об'єкта, до якого прив'язана подія.
49. Що таке LocalStorage і SessionStorage? Який максимальний розмір LocalStorage?
- LocalStorage і SessionStorage - це механізми для зберігання даних на стороні клієнта (браузера). Вони схожі за функціональністю, але відрізняються тим, що:
- LocalStorage зберігає дані без обмеження строку життя, поки їх не видалити вручну або не очистити кеш браузера.
- SessionStorage зберігає дані лише протягом одного сеансу браузера, тобто вони будуть видалені після закриття вкладки або вікна браузера.
- Максимальний розмір LocalStorage зазвичай становить 5-10 МБ.
50. Як отримати висоту блоку? Його положення щодо меж документа?
- Висоту блоку можна отримати за допомогою властивості offsetHeight або методу clientHeight.
- Положення блоку відносно меж документа можна отримати за допомогою властивості offsetTop.
51. Що таке webpack?
- Webpack - це інструмент для збірки (bundling) і управління залежностями JavaScript-додатків. Він дозволяє об'єднувати багато файлів JavaScript в один або декілька файлів для оптимізації завантаження додатка в браузері.
52. Чим відрізняється dev-збірка від prod?
- dev-збірка (розробницька збірка) призначена для розробки і зазвичай не оптимізована. Вона може містити недооптимізований код, додаткову інформацію для налагодження і не бути мініфікованою.
- prod (продакшн-збірка) призначена для продакшну і містить оптимізований, мініфікований код без додаткової інформації для налагодження. Вона зазвичай має менший розмір і завантажується швидше.
### Верстка
53. Що таке блокова модель CSS?
- Блокова модель CSS - це основний принцип організації елементів на веб-сторінці з використанням CSS. Вона визначає, як елементи відображаються на сторінці, включаючи розміри, відступи, рамки, поля та інші характеристики. Блокова модель включає в себе властивості width, height, margin, padding, border, і деякі інші.
54. Які способи центрування блокового контенту по горизонталі та вертикалі знаєте?
- По горизонталі:
  1. text-align: center; для контейнера і display: inline-block; для самого блоку.
  2. margin: 0 auto; для блоку з фіксованою шириною.
  3. flexbox і justify-content: center; для контейнера.
  4. grid і justify-items: center; для контейнера.
- По вертикалі:
  1. position: relative; для контейнера і position: absolute; top: 50%; transform: translateY(-50%); для блоку.
  2. flexbox і align-items: center; для контейнера.
  3. grid і align-items: center; для контейнера.
55. Які підходи у верстці вам відомі (float, flex, grid, etc)?
- float: Застарілий метод, який використовується для розміщення елементів в струмину.
- flexbox: Гнучкий метод для розміщення елементів у великому контейнері, з багатьма можливостями розташування.
- grid: Розкладка елементів у таблиці з рядками і стовпцями.
- Ще існують методи відмінностей, такі як position, display, float тощо.
56. Як зробити додаток responsive?
- Робота додатка responsive передбачає, що додаток виглядає і працює добре на різних пристроях та розмірах екрану. Це досягається за допомогою резинового (fluid) дизайну, медіазапитів (media queries), і відповідних стилів для різних розмірів екрану.
57. Які є принципи семантичної верстки?
- Використання правильних HTML-тегів для правильного семантичного значення.
- Використання заголовків (`<h1>`, `<h2>` тощо) для ієрархії тексту.
- Використання списків (`<ul>`, `<ol>`) для переліків і табличних структур для таблиць.
- Використання атрибутів alt для зображень для покращення доступності.
- Завдання класів і id з обережністю і для явної ролі в CSS, і не для стилізації.

58. Навіщо потрібні префікси для деяких CSS-властивостей (-webkit-, -moz- тощо)?
- Префікси для CSS-властивостей (-webkit-, -moz- тощо) використовуються для забезпечення сумісності з різними браузерами, особливо при використанні експериментальних або нестандартних CSS-властивостей. Деякі браузери можуть потребувати префікси для властивостей, які ще не були стандартизовані.
59. Як спростити написання кросбраузерних стилів?
- Спрощення написання кросбраузерних стилів можна досягти за допомогою CSS-препроцесорів (наприклад, Sass або Less), які дозволяють використовувати змінні, мікси, і інші функції для зручності і перевикористання коду. Також важливо тестувати стилі на різних браузерах і використовувати плагіни для автоматичного вставлення вендорних префіксів.
60. Практичне завдання: прокоментувати та виправити приклад поганого CSS або HTML.
61. Що таке CSS-препроцесори? З якими працювали? Що нового вони приносять у стандартний CSS?
- CSS-препроцесори - це мови розширення CSS, які додають додаткові функції і можливості до звичайного CSS. Деякі з них включають Sass, Less і Stylus. Вони дозволяють використовувати змінні, мікси, умовні оператори і багато інших корисних функцій для покращення організації і підтримки коду. Препроцесори компілюються в звичайний CSS для використання в браузері.
### React
62. Чи працювали з класовими компонентами? У чому їхня особливість?
- Так, класові компоненти були попередньою основною способом написання компонентів у React до введення хуків.
63. Які дані краще зберігати в стані компонента, а які передавати через пропси? Наведіть приклад.
- Дані, які повинні змінюватися і впливати на відображення компонента, краще зберігати в стані компонента. Наприклад, введення користувача в формі або стан, який змінює відображення компонента.
- Дані, які залишаються сталими або передаються з батьківського компонента в дочірній, краще передавати через пропси.
64.Чи ознайомлені з хуками? У чому їхні переваги? Чи доводилося робити свої і з якою метою?
- Хуки (hooks) - це функції, які дозволяють використовувати функціональність React у функціональних компонентах. Вони вводяться у React з метою полегшення створення і керування станом, ефектами та іншими функціональностями компонентів. Їх переваги включають зручність, повторне використання, і більшу зрозумілість коду.
65.Чи ознайомлені з фрагментами та порталами? Навіщо вони потрібні?
- Фрагменти (<React.Fragment>) використовуються для об'єднання декількох дочірніх елементів без створення надмірних DOM вузлів.
- Портали (portals) дозволяють вставити дочірні елементи в інший DOM вузол, який може бути поза кореневим DOM елементом вашого додатка.
66. Коли й для чого використовують рефи?
- Рефи (refs) використовуються для доступу до реальних DOM елементів або екземплярів компонентів у React. Вони використовуються рідко і зазвичай в ситуаціях, коли інші підходи не підходять. Наприклад, для фокусування на певному полі вводу або виміру розміру DOM елементу.
67. Які ви знаєте методи життєвого циклу компонента?
- Методи життєвого циклу компонента включають componentDidMount, componentDidUpdate, componentWillUnmount та інші. Вони дозволяють вам впливати на різні аспекти життєвого циклу компонента, такі як ініціалізація, поновлення і знищення. [Детально](https://www.linkedin.com/pulse/%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B8-%D0%B6%D0%B8%D1%82%D1%82%D1%94%D0%B2%D0%BE%D0%B3%D0%BE-%D1%86%D0%B8%D0%BA%D0%BB%D1%83-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0-%D0%B2-react-%D0%BE%D0%B4%D0%B8%D0%BD-%D0%B7-%D0%BD%D0%B0-aleksieieva/)
68. В якому методі життєвого циклу компонента краще робити запити на сервер? Чому?
- Запити на сервер краще робити в методі життєвого циклу componentDidMount. Це рекомендується, оскільки цей метод викликається після того, як компонент вперше рендериться і може бути використаний для ініціалізації даних. Також в цьому методі можна використовувати асинхронні запити до сервера, і це не блокуватиме рендеринг компонента.
69. В якому методі життєвого циклу компонента краще робити підписку і відписку від лістенера? Чому? Навіщо відписуватися?
- Підписку на лістенера краще робити в методі componentDidMount, а відписку - в методі componentWillUnmount, щоб забезпечити належний порядок і запобігти помилкам. Відписка важлива для звільнення ресурсів і уникнення витоку пам'яті.
70. Чи був досвід роботи з контекстом? Коли його варто використовувати?
- Контекст в React використовується для передачі даних вниз по дереву компонентів, без необхідності передачі пропсів через кожен проміжний компонент. Контекст варто використовувати, коли потрібно зберігати та передавати дані глибоко в компонентах без необхідності їхньої передачі через багато проміжних компонентів.
71. У чому особливість PureComponent?
- PureComponent - це класовий компонент у React, який автоматично виконує перевірку на зміну пропсів та стану перед рендерингом. Якщо пропси та стан не змінилися, компонент не рендериться повторно. Основна відмінність від звичайного класового компонента полягає в автоматичному визначенні shouldComponentUpdate.
72. Чи працював з мемоізованими селекторами (memoized selectors)? Для чого їх використовують і який принцип роботи?
- Так, мемоізовані селектори використовуються для оптимізації селекторів у бібліотеці управління станом, такій як Redux або Reselect. Вони зберігають результати обчислення селекторів і оновлюють їх тільки при зміні вхідних даних, що дозволяє уникнути зайвих обчислень і покращити продуктивність додатку. Робота полягає у кешуванні результатів селекторів і їх повторному використанні при однакових вхідних даних.
73. У чому бачите переваги бібліотеки React?
- Переваги бібліотеки React включають в себе простоту використання, реактивний підхід до UI, велику активну спільноту та багато розширень і бібліотек для розробки.
74. Чому бібліотека React швидка? Що таке Virtual DOM і Shadow DOM?
- Бібліотека React швидка завдяки використанню Virtual DOM. Вона створює віртуальне представлення DOM структури і порівнює його з реальним DOM для ефективного визначення, які частини сторінки потребують оновлення. Shadow DOM - це технологія, яка дозволяє ізолювати CSS і JavaScript від інших частин сторінки, але вона не прямо пов'язана з React.
75. Навіщо в списках ключі? Чи можна робити ключами індекси елементів масиву? Коли це виправдано?
- Ключі (keys) використовуються в React для ідентифікації і відслідковування елементів в списку під час оновлення. Ключі допомагають React оптимізувати процес відображення і визначити, які елементи додалися, видалилися або змінили своє положення в списку. Ключі можуть бути індексами, але рекомендується використовувати унікальні значення для кращої ефективності.
76. В чому основна ідея Redux?
- Redux - це бібліотека для управління станом додатку в React (і інших бібліотеках). Основна ідея - зберігати стан додатку в одному централізованому об'єкті (стор), який може бути змінений лише за допомогою дій (actions). Це спрощує управління станом, робить його передбачуваним і полегшує тестування.
77. Робота зі стилями в React.
- Робота зі стилями в React може включати в себе використання CSS модулів, CSS-in-JS бібліотек, inline-стилів і багато інших підходів. Зазвичай, рекомендується використовувати той підхід, який вам зручний і відповідає потребам вашого проєкту.
78. React — це бібліотека чи фреймворк? Яка різниця між цими двома поняттями.
- React - це бібліотека для створення інтерфейсів користувача, не фреймворк. Основна різниця полягає в тому, що React не нав'язує жорстку структуру проєкту і залишає більше свободи вибору інших технологій і бібліотек для інших аспектів розробки.
79. Чи можна використовувати jQuery разом з React? Чому так / ні?
- jQuery і React можна використовувати разом, але це не завжди рекомендується. React керує відображенням і станом компонентів, в той час як jQuery оперує DOM напряму. Це може призвести до конфліктів і проблем зі синхронізацією.
80. Що таке codemod?
- Codemod - це інструмент для автоматизованої зміни (рефакторингу) вихідного коду програми. Він може бути використаний для оновлення коду до нових версій бібліотек або фреймворків, заміни застарілих API та інших масштабних змін в коді.
81. Чи доводилося налаштовувати проєкт React з нуля? За допомогою яких інструментів ви це робили?
- 
82. Перерахуйте всі бібліотеки, які використовували у зв’язці з React.
- Бібліотеки, що використовуються з React, можуть включати Redux для керування станом, React Router для маршрутизації, Axios або Fetch для роботи з API, і різні бібліотеки для роботи зі стилями, такі як Styled Components або CSS модулі.
83. Що найскладніше доводилося реалізовувати за допомогою React?
- 
### Back-end
84. Що таке REPL?
- REPL (Read-Eval-Print Loop) - це інтерактивна оболонка або середовище, яке дозволяє виконувати код або команди одразу після їх введення. Наприклад, використовується в багатьох мовах програмування, таких як Python, JavaScript (у вигляді консолі браузера) і інших, для експериментів, тестування коду та швидкого відлагодження.
85. Що таке streams в Node.js?
- Streams в Node.js - це концепція для роботи з потоками даних, такими як читання файлів або передача даних по мережі. Вони дозволяють обробляти дані порціями, замість завантаження всього об'єму даних в пам'ять, що зменшує використання ресурсів і покращує продуктивність.
86. Що таке middleware?
- Middleware - це функції або програмний код, який обробляє запити і відповіді веб-додатку. Вони дозволяють виконувати певні дії або перетворювати дані перед тим, як вони надсилаються клієнту або обробляються сервером. Middleware використовується, наприклад, в Express.js для обробки маршрутів, аутентифікації, логування тощо.
87. Для чого використовують функцію setImmediate?
- Функція setImmediate в Node.js використовується для планування виконання функцій після завершення поточного циклу подій (event loop). Вона дозволяє виконати функцію асинхронно, але негайно після завершення поточного коду, а не чекати наступного циклу подій, як робить setTimeout.
88. Навіщо потрібен app.param() в express?
- app.param() в Express використовується для обробки параметрів маршрутів. Він дозволяє визначити функції обробки, які виконуються автоматично для певних параметрів, що входять до маршруту. Наприклад, ви можете використовувати app.param() для перевірки і валідації параметрів перед обробкою запиту.
89. Що таке token based authentication?
- Token-based authentication (аутентифікація на основі токенів) - це метод аутентифікації, при якому користувач отримує токен після успішної аутентифікації, і цей токен використовується для подальших запитів замість повторної передачі облікових даних (наприклад, логін і пароль) з кожним запитом. Токени зазвичай використовуються в API для забезпечення безпеки і автентифікації користувачів.
### Бази даних
90. Напишіть простий запит для обчислення трьох авторів, у яких найбільше книг.
```
SELECT author_id, COUNT(book_id) AS book_count
FROM books
GROUP BY author_id
ORDER BY book_count DESC
LIMIT 3;
```
91. Напишіть запит, який вибирає останні три коментарі для конкретного користувача для двох таблиць: коментарі та користувачі.
```
SELECT comments.comment_text, comments.comment_date
FROM comments
INNER JOIN users ON comments.user_id = users.user_id
WHERE users.username = 'desired_username'
ORDER BY comments.comment_date DESC
LIMIT 3;
```
92. Спроєктуйте просту схему бази даних для бібліотеки.
- Таблиця "книги" містить поля: book_id, title, author_id, category_id, publish_date тощо.
- Таблиця "автори" містить поля: author_id, name, birth_date тощо.
- Таблиця "категорії" містить поля: category_id, name тощо.
93. Для чого використовують SQL-оператор HAVING?
- SQL-оператор HAVING використовується для фільтрації групованих результатів запиту, на відміну від WHERE, який фільтрує рядки до групування. Його використовують для обчислення агрегатних функцій (наприклад, COUNT, SUM, AVG) на групах і виключення груп, які не відповідають певному умовному виразу.
94. Навіщо використовують SQL-оператор LEFT JOIN?
- SQL-оператор LEFT JOIN використовується для об'єднання двох таблиць на основі спільного значення у лівій таблиці, і повертає всі записи з лівої таблиці та відповідні записи з правої таблиці. Якщо відповідні записи не існують у правій таблиці, то результат все одно включає запис з лівої таблиці з NULL значеннями у відповідних стовпцях правої таблиці.
95. Чим відрізняється embed- від reference-зв’язку в MongoDB?
- У MongoDB embed-зв'язок передбачає включення документів однієї колекції в поле іншого документа. Він дозволяє зберігати пов'язані дані в одному документі, що спрощує читання та оновлення даних, але може призвести до зростання розміру документа.
Reference-зв'язок полягає в тому, що в поле записується посилання на ідентифікатор документа з іншої колекції. Він дозволяє ефективно керувати великими об'ємами даних і зменшує розмір документів, але вимагає додаткового запиту для отримання пов'язаних даних.
96. В одному проєкті програмісти зберігають дані в MongoDB-колекції коментарів, використовуючи такі типи даних (дивіться нижче). Що поганого в цьому рішенні?
```
id: ObjectID
text: string
author_id: string
created_at: Date
```
- Проблема в тому, що поле "author_id" містить значення типу "string" для посилання на автора. Зазвичай для ідентифікаторів об'єктів в MongoDB використовуються значення типу ObjectId, які є унікальними ідентифікаторами для кожного документа. Використання рядкового значення може призвести до неконсистентності та ускладнити подальшу роботу з даними.
97. У проєкті знадобилося внести зміни в структуру таблиць, додати кілька полів і індекси. Як програмісти будуть робити це на продакшені?
- Розробники розробляють SQL-скрипти, які описують необхідні зміни в структурі бази даних.
- Скрипти перевіряються та тестуються в окремому тестовому середовищі.
- Після підтвердження тестування скрипти застосовуються на продакшені під час планового технічного обслуговування або оновлення.
- Важливо виконувати резервне копіювання даних перед внесенням змін на продакшені, щоб уникнути втрати даних в разі помилок або непередбачуваних проблем.
### Інструменти
98. Щоразу, коли ви робите pull, чомусь трапляється конфлікт в останньому рядку в усіх файлах, які ви редагували. Що відбувається?
- Конфлікт в останньому рядку при виконанні операції pull може виникнути, якщо два або більше користувачі редагують один і той самий рядок в одному і тому ж файлі відомому як "конфлікт при злитті" (merge conflict). Git не може вирішити, чий варіант коду вважати правильним, і тому він залишає цей вибір користувачеві під час розробки.
99. Що робить команда git fetch?
- Команда git fetch витягує всі зміни з віддаленого репозиторію, але не об'єднує їх з поточними гілками. Вона оновлює інформацію про гілки і коміти на віддаленому репозиторії, щоб ви могли переглянути їх, але не впливає на вашу робочу копію. Для злиття цих змін з віддаленими гілками ви повинні використовувати команду git pull або git merge.
100. Які git hygiene підходи ви знаєте?
- Git hygiene (гігієна Git) включає в себе набір кращих практик і правил щодо роботи з Git-репозиторіями. Деякі з цих підходів включають в себе регулярне збирання сміття (git garbage collection), використання понятливих назв гілок та комітів, регулярну синхронізацію з віддаленим репозиторієм, використання гілок для функціональної розробки тощо.
101.Що таке CI/CD? Для чого це потрібно?
- CI/CD (Continuous Integration / Continuous Deployment) - це практика автоматизації процесів розробки, тестування та розгортання програмного забезпечення. Вона дозволяє розробникам інтегрувати свій код в спільний репозиторій та автоматично тестувати його, забезпечуючи стабільність програми. Після успішних тестів CI/CD автоматично розгортає нову версію програми в продакшен. Це покращує якість програмного забезпечення, швидкість розробки та забезпечує автоматизацію важливих етапів розробки.

## Middle
### Загальні

1. Розкажіть про піраміду тестування.
- Піраміда тестування - це концепція, яка описує структуру і співвідношення різних типів тестів в розробці програмного забезпечення. Зазвичай піраміда тестування включає такі рівні тестування:
- Unit-тести: Тести, які перевіряють окремі функції або модулі програми на найнижчому рівні. Вони мають бути швидкими і мають гарантувати коректну роботу окремих частин коду.
- Integration-тести: Тести, які перевіряють взаємодію між різними модулями або компонентами програми. Вони допомагають виявити проблеми, які можуть виникнути при спільній роботі різних частин системи.
- UI (User Interface) тести: Тести, які перевіряють коректність роботи інтерфейсу користувача. Ці тести можуть включати автоматизоване тестування веб-сторінок або інших графічних інтерфейсів.
- Піраміда вказує, що unit-тести повинні бути найбільшою частиною тестів, а UI тести - найменшою. Це обумовлено тим, що unit-тести легко писати і виконувати, і вони зазвичай знаходять більше помилок на ранніх етапах розробки.
2. Які типи автоматизованих тестів випадала нагода писати? Які бібліотеки при цьому використовували? Яким інструментам віддаєте перевагу і чому?
- Основні типи автоматизованих тестів включають:
- Unit-тести: Перевіряють окремі функції або методи на коректність роботи. Зазвичай використовують бібліотеки, такі як Mocha (JavaScript).
- Integration-тести: Перевіряють взаємодію між різними частинами системи. Для цього можна використовувати фреймворки, такі як Jest (JavaScript).
- UI тести: Перевіряють коректність роботи інтерфейсу користувача. Для веб-додатків можна використовувати Selenium, Cypress, Puppeteer.
- Функціональні тести: Перевіряють, чи виконує програма очікувані функціональні вимоги.
3. Що таке unit-тести? Яке місце в піраміді тестування займають unit-тести?
- Unit-тести - це тести, які перевіряють найменші можливі одиниці програми, такі як окремі функції, методи або класи. Вони зазвичай мають бути швидкими, ізольованими і незалежними один від одного. Мета unit-тестів - переконатися, що кожна окрема частина програми працює правильно.
- У піраміді тестування unit-тести розміщуються внизу, на базовому рівні. Вони є фундаментом для інших типів тестів, таких як інтеграційні і UI тести.
4. Що таке code coverage? Чи обов’язкове 100% покриття тестами коду?
- Code coverage (покриття коду) - це метрика, яка визначає, яка частина програмного коду була виконана під час виконання тестів. Вона вимірюється у відсотках і може бути корисною для визначення, наскільки добре код відтестований.
- Не обов'язково досягати 100% покриття коду тестами, хоча в деяких проектах це може бути ціллю. Важливо забезпечити достатню кількість тестів, які покривають критичні шляхи в програмі і ті місця, де можливі помилки. 100% покриття не завжди є практичним і може призвести до написання зайвих тестів.
5. Як заборонити браузеру віддавати кеш на HTTP-запит?
- Для заборони браузеру віддавати кеш на HTTP-запит ви можете використовувати HTTP заголовки. Два заголовки, які можна використовувати для цієї мети, - це "Cache-Control" і "Pragma". Ось приклади:
- Використання "Cache-Control: no-store" запропонує браузеру не зберігати кешовані дані і завжди запитувати їх з сервера.
- Використання "Cache-Control: no-cache" запропонує браузеру не використовувати кеш безпосередньо, але перевіряти з сервером перед використанням.
- Використання "Pragma: no-cache" є застарілим, але також може бути використаним для запиту браузера не кешувати ресурс.
6. Що таке XSS (Cross-Site Scripting)?
- XSS (Cross-Site Scripting) - це тип атаки на веб-додатки, при якому зловмисник вставляє веб-скрипти в веб-сторінку, яка потім виконується у браузері користувача. Ця атака може призвести до крадіжки інформації користувача, перенаправлення на інші сторінки або виконання небажаних дій на сторінці.
- Щоб запобігти XSS-атакам, рекомендується використовувати валідацію вхідних даних, екранизацію виведених даних та використання безпечних бібліотек і фреймворків.
7. Розкажіть про патерни Observer, Pub / Sub. Яка між ними різниця? Наведіть приклади реалізації цих патернів у відомих фреймворках / бібліотеках / браузерних API.
- Паттерни Observer і Pub/Sub використовуються для реалізації взаємодії між об'єктами в програмах.
- Observer: Цей паттерн включає в себе один об'єкт (спостерігач), який слідкує за іншими об'єктами (суб'єктами) і реагує на їх зміни. Спостерігач реєструється на суб'єкті і отримує сповіщення про зміни. Приклади реалізації: Java Observable і Observer, JavaScript EventListener.
- Pub/Sub (Publisher/Subscriber): Цей паттерн використовує інтермедіарі (посередника), який відправляє повідомлення (події) підписникам, які цікавляться цими подіями. Підписники не спільникують напряму один з одним. Приклади реалізації: JavaScript EventEmitter, бібліотека Redis Pub/Sub.
- Різниця між ними полягає в тому, як вони організовують взаємодію між об'єктами: Observer передає повідомлення від одного об'єкта до іншого, тоді як Pub/Sub використовує посередника для розповсюдження подій.
8. З якою метою може бути використаний event listener події fetch self.addEventListener(’fetch’, event => {}) ?
- Event listener події "fetch" (self.addEventListener('fetch', event => {})) використовується для перехоплення HTTP-запитів, які відправляються відстежувачем (service worker) в веб-додатку. Цей event listener дозволяє вам впливати на обробку запитів, наприклад, кешувати їх, використовувати стратегії кешування, або відправляти модифіковану відповідь.
- Використовуючи event listener "fetch", ви можете створити різноманітні стратегії кешування і забезпечити офлайн доступ до ресурсів. Це особливо корисно для прогресивних веб-додатків (PWA).
9. Що таке Event loop і як він працює? Розкажіть про мікрозадачі та макрозадачі.
- Event loop - це механізм в браузері або середовищі виконання JavaScript, який контролює виконання асинхронного коду. Він працює в циклі і відповідає за обробку подій, завдань і запитів.
- Мікрозадачі (microtasks) - це завдання, які виконуються після поточного виконання макрозадачі (macrotask), такої як обробка подій або виконання асинхронного коду.
- Мікрозадачі зазвичай мають вищий пріоритет і виконуються
### JS Core
10. Які типи даних бувають у JavaScript? Який буде результат виконання [коду](https://carbon.now.sh/rDyOjpu0vvgvo8CdAvxr)?
```
let firstObj = { name: 'Hello' };

let secondObj = firstObj;

firstObj = { name: 'Bye' };

console.log(secondObj.name);
```

11. Що таке temporal dead zone?
- Temporal Dead Zone (TDZ) - це специфічний стан в JavaScript, пов'язаний з змінними, оголошеними за допомогою ключових слів let і const. Під час фази виконання коду, перед тим як змінні отримають значення, вони перебувають у стані TDZ. В цьому стані будь-яка спроба звернутися до такої змінної призведе до виникнення ReferenceError.
```
console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x = 10;
```

12. Як працює boxing / unboxing у JavaScript?
- Boxing і unboxing в JavaScript відбувається при роботі з примітивами і об'єктами-обгортками (wrapper objects). JavaScript автоматично обгортає (boxing) примітиви у відповідні об'єкти-обгортки, коли ви виконуєте операції, які вимагають об'єктів, наприклад, доступ до властивостей або методів. Потім, при необхідності, JavaScript автоматично розпаковує (unboxing) значення, отримані з об'єктів-обгорток, для роботи з ними як зі звичайними примітивами.
```
let num = 42; // примітив
let str = "Hello"; // примітив

let numObj = new Number(num); // boxing - обгортаємо число в об'єкт
let strObj = new String(str); // boxing - обгортаємо рядок в об'єкт

let sum = numObj + 10; // unboxing - розпаковуємо об'єкт для операції

console.log(typeof numObj); // "object"
console.log(typeof sum); // "number"
```

13. У чому різниця між оператором in і методом hasOwnProperty?
- Оператор in: Перевіряє, чи існує властивість в об'єкті або в його прототипному ланцюгу. Він повертає true, якщо властивість знайдена.
- Метод hasOwnProperty: Перевіряє, чи існує властивість в об'єкті, але не перевіряє прототипи. Він повертає true, якщо властивість знайдена без перевірки прототипного ланцюга.
14. Опишіть, за допомогою чого в JS реалізуються такі ООП-парадигми, як інкапсуляція, поліморфізм, абстракція?
- Інкапсуляція: Інкапсуляція в JavaScript досягається за допомогою замикань (closures) і приватних змінних. Властивості і методи, які не потрібно робити публічними, можуть бути приховані внутрішніми функціями і змінними. Приклад:
- Поліморфізм: Поліморфізм в JavaScript може бути реалізованим шляхом використання однойменних методів у різних об'єктів чи прототипах. Об'єкти можуть вести себе по-різному, викликаючи однакові методи. Це називається динамічним поліморфізмом.
- Абстракція: Абстракція в JavaScript означає скриття деталей реалізації і надання користувачу інтерфейсу для взаємодії з об'єктом. Це досягається через визначення методів і властивостей об'єкта, які представляють лише необхідні деталі для користувача, приховуючи внутрішні реалізаційні деталі.
15. Що таке прототип? Як працює прототипне наслідування в JS? Поясніть роботу [коду](https://carbon.now.sh/IhjDlxZwvH7rxq8JlXhO).
```
function Main () {}
Main.prototype = { protected: true };

const obj = new Main();
Main.prototype = { protected: false };

console.log('Object protection: ', obj.protected); 
```
16. Яка різниця між композицією та наслідуванням?

17. Чому не варто використовувати конструктори типу new String?

18. Розкажіть про базовий пристрій і механізм роботи Event loop.

19. Що таке записи (records) і кортежі (tuples)? Чим вони відрізняються від звичайних об’єктів?

20. Які відмінності в поведінці ES5 функції-конструктора та ES2015 класу?

21. Як реалізувати патерн «Модуль»?

22. Чому typeof null повертає object?

23. Що таке приведення (перетворення) типів у JS?

24. Що таке явне і неявне приведення (перетворення) типів даних у JS? Як відбувається перетворення типів у таких прикладах:
```
{}+[]+{}+[1]
!!"false" == !!"true"
['x'] == 'x'
```
25. Що таке Garbage Collector?
- Garbage Collector (збирач сміття) в JavaScript - це автоматизований механізм, який відслідковує та видаляє об'єкти, які більше не використовуються в програмі, для ефективного управління пам'яттю в браузері або середовищі виконання JavaScript. Головна функція збирача сміття - це звільнення пам'яті, щоб запобігти витокам пам'яті і підтримувати продуктивність програми.
26. Опишіть основні принципи роботи «збирача сміття» у JS-рушіях (engines).
- Аналіз доступності: Збирач сміття визначає, які об'єкти в пам'яті доступні і можуть бути використані програмою. Всі об'єкти, на які немає посилань (закриті для доступу), вважаються сміттям.
- Маркування: Збирач сміття розпочинає з "кореневих" об'єктів, таких як змінні, які мають глобальний область видимості (наприклад, window у веб-середовищі). Він рекурсивно переходить по всіх посиланнях і маркує об'єкти, які вони доступні.
- Сканування: Після маркування збирач сміття сканує всю пам'ять і виявляє об'єкти, які не були позначені під час маркування. Ці об'єкти вважаються сміттям і підлягають подальшому видаленню.
- Очищення і звільнення пам'яті: Збирач сміття видаляє сміття, звільнюючи пам'ять для подальшого використання.
- Компактизація (не завжди): Деякі "збирачі сміття" можуть проводити операцію компактизації, де залишковий об'єм пам'яті зсувається, щоб пам'ять була більш ефективною для майбутнього використання.
- Розкладання на етапи: Збирач сміття може розподіляти свою роботу на декілька етапів, щоб не призводити до блокування виконання програми на тривалий час.
27. Опишіть призначення і принципи роботи з колекціями WeakMap і WeakSet? Чим вони відрізняються від колекцій Map і Set відповідно?

28. Чим відрізняється Observable від Promise?

29. Що таке Promise? Назвіть порядок виконання then і catch у ланцюжку.
```
Promise.resolve(10)
  .then(e => console.log(e)) // ??
  .then(e => Promise.resolve(e))
  .then(console.log) // ??
  .then(e => {
    if (!e) {
      throw 'Error caught';
    }
  })
  .catch(e => {
    console.log(e); // ??
    return new Error('New error');
  })
  .then(e => {
    console.log(e.message); // ??
  })
  .catch(e => {
    console.log(e.message); // ??
  });
  ```
30. Розкажіть про послідовне і паралельне виконання асинхронних функцій. У чому різниця між Promise.all () і Promise.allSettled ()?

31. Що таке дескриптори властивостей об’єктів? Розкажіть про їхнє практичне застосування.

32. Назвіть кілька способів створення незмінного об’єкта в JavaScript.

33. Як створити властивість в об’єкта, яку не можна буде змінити?
- Ви можете створити незмінну (immutable) властивість в об'єктах JavaScript, використовуючи метод Object.defineProperty(). Цей метод дозволяє вам налаштувати властивість з певними атрибутами, включаючи writable, який контролює можливість зміни властивості.
```
  const obj = {};

// Встановлюємо властивість "name" і робимо її незмінною
Object.defineProperty(obj, 'name', {
  value: 'John',     // Значення властивості
  writable: false,   // Робимо незмінною
  configurable: false // Не дозволяємо змінювати атрибути властивості
});

console.log(obj.name); // "John"

// Спроба змінити значення властивості призведе до помилки:
obj.name = 'Alice'; // TypeError: Cannot assign to read-only property 'name' of object

```
34. Навіщо потрібен конструктор Proxy? Наведіть приклад використання.

35. Що таке ArrayBuffer? У чому різниця між Uint32Array і Float32Array? Який результат виконання коду?
```
const uint32Array = new Uint32Array();
Array.isArray(uint32Array);
36.Яким буде результат порівняння?

const url = “HTTPs://xyz.com/path<to>page.html”;
encodeURI(url) == encodeURIComponent(url); 
37.Розкажіть про генератори та ітератори.
38.. Поясніть, що робить наведений код:

function * fn(num) {
  for (let i = 0; i < num; i += 1) {
    yield console.log(i);
  }
}
const loop = fn(5);
loop.next();
loop.next();
```
39.Розкажіть про тип даних Symbol і його практичне застосування. Як перевести число з 10-розрядної системи в 16(2,8)-розрядну систему числення?
```
const decimalNumber = 255;

const hexNumber = decimalNumber.toString(16); // 16-розрядна система
const binaryNumber = decimalNumber.toString(2); // 2-розрядна система
const octalNumber = decimalNumber.toString(8); // 8-розрядна система
```
###Функції
40.Поясніть, що означає currying. Наведіть приклад використання на практиці.
41.Наведіть приклад функції з мемоізацією. Коли варто застосовувати цю техніку?
42.Що таке чейнінг функцій? Напишіть приклад з використанням цього підходу.
43.У чому різниця між function і arrow function? Яким буде результат виконання коду?

const pluckDeep = key => obj => key.split('.').reduce((accum, key) => accum[key], obj)

const compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res)

const unfold = (f, seed) => {
  const go = (f, seed, acc) => {
    const res = f(seed)
    return res ? go(f, res[1], acc.concat([res[0]])) : acc
  }
  return go(f, seed, [])
}
Front-end
44.У чому принципова різниця між подіями mouseleave і mouseout?
45.У якому порядку обробляються призначені для користувача події в DOM (click, mouseover тощо)? FIFO чи LIFO?
46.Що таке Event bubbling та Event capturing?
47.Порівняйте методи об’єкта event stopPropagation та stopImmediateProparation.
48.Які є підходи оптимізації продуктивності вебсторінки?
49.Як реалізований механізм same-origin policy в браузері? На які браузерні API він поширюється?
50.Назвіть способи зберігання даних у браузері. Порівняйте їх.
51.Web worker’и. Опишіть особливості передачі даних між worker’ами та основним потоком, між розділеними worker’ами.
51.Що таке Transferable-об’єкти?
52.Розкажіть про способи оптимізації виконання ресурсомістких операцій JS для поліпшення продуктивності рендерингу контенту на сторінці.
53.Чому ResizeObserver викликає події зміни розміру до відтворення елемента, а не після?
54.Розкажіть, як ви розумієте Web Accessibility?
55.Опишіть алгоритм створення функціоналу, що забезпечує читання вмісту .txt-файлу при перетягуванні його з файлової системи у вікно браузера.
56.Що таке Virtual DOM?

## Senior
### Загальні
1. Розкажіть про функціональне програмування.

2. Що таке TDD (Test Driven Development) / BDD (Behavior Driven Development)?

3. Розкажіть детально про роботу HTTPS.

4. Який стек технологій можна обрати для реалізації клону якогось відомого проєкту і чому?

5. Є проєкт на старих технологіях, необхідно в нього вносити зміни. Як це зробити найкраще?

6. Якщо у кандидата є досвід роботи з кількома фреймворками: який будете використовувати для наступного проєкту? Які фактори будуть впливати на вибір?

7. Що таке V8 Engine?

### JS Core
8. Реалізація патерну Class Free OOP (HTTPs://observablehq.com/@bratter/class-free-oop).

9. Патерн async disposer (HTTPs://advancedweb.hu/what-is-the-async-disposer-pattern-in-javascript).

10. Використання регулярних виразів. Коли прийнятно / неприйнятно? Як вони працюють? Як можна зробити читабельним код?

### Front-end
11. Як браузер визначає, чи ми можемо спілкуватися між вкладками?

12. Що таке Content Security Policy?

13. Як уникнути завантаження кешованих файлів скриптів і стилів?

14. Що таке requestAnimationFrame?

15. Розкажіть про мікросервісну архітектуру Front-end App.

16. Що таке Shadow DOM?

17. Порівняйте nextElementSibling та nextSibling.

18. Які знаєте метрики вебсайту?

### Back-end
19. Порівняйте Common.js з AMD Modules та ES6 Imports.

20. Який фреймворк вибрали б для бекенду, чому?

21. Опишіть своїми словами, як працює OAuth v2.

22. Є проєкт з джерелами витоку пам’яті, як їх виявити, усунути та запобігти цьому в майбутньому?

23. Є проєкт з performance issues, як їх виявити, усунути та запобігти в майбутньому?

### Бази даних
24. Які альтернативні види баз даних використовуєте?

25. Що таке RDS і чому він іноді не підходить?

26. Що таке SQL Injections і як їх уникнути?

27. Чому для запитів у БД треба використовувати плейсхолдери?

28. Як спроєктувати кластер на MongoDB?

29. Для чого використовують MongoDB Aggregation framework?

30. Розкажіть про GraphQL.

### Інструменти
31. Чи можете описати суть методології git flow двома словами?

32. Що означає вимога робити squash commits під час rebase?

33. Яка ваша думка про альтернативні системи контролю версій (Version Control System)?

34. Які конвенції знаєте і використовуєте для git?

35. Розкажіть про свій досвід використання / впровадження СI/CD.

36. Потрібно налаштувати деплой проєкту на кілька середовищ. Розкажіть, як би ви побудували процес? Які інструменти використали б?
