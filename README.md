# JavaScript_Interview_Questions
## Junior
### Загальні
1. Які методи HTTP-запитів ви знаєте? 
- HTTP (Hypertext Transfer Protocol) має кілька методів запитів, основні з них:

  1.  GET: Використовується для отримання даних з сервера.
  2. POST: Використовується для надсилання даних на сервер для створення нового ресурсу.
  3. PUT: Використовується для оновлення існуючого ресурсу на сервері.
  4. DELETE: Використовується для видалення ресурсу на сервері.
  5. HEAD: Схожий на GET, але повертає лише заголовки без тіла відповіді.
  6. OPTIONS: Використовується для отримання інформації про можливі методи та параметри ресурсу.

2. Які версії HTTP-протоколу вам відомі?
- HTTP/1.0
- HTTP/1.1
- HTTP/2
- HTTP/3
3. Які знаєте коди відповіді (стану) HTTP?
- 200 OK: Успішний запит.
- 201 Created: Ресурс успішно створений.
- 204 No Content: Запит виконаний, але немає даних для передачі.
- 400 Bad Request: Помилка у запиті від клієнта.
- 401 Unauthorized: Вимагається автентифікація для доступу.
- 403 Forbidden: Доступ заборонено через обмеження сервера.
- 404 Not Found: Ресурс не знайдено.
- 500 Internal Server Error: Внутрішня помилка сервера.
4. Що таке Cross-Origin Resource Sharing? Як усунути проблеми з CORS?
- Cross-Origin Resource Sharing (CORS) - це механізм безпеки в браузерах, який контролює доступ клієнта до ресурсів на іншому домені (орієнтований на джерело). Щоб усунути проблеми з CORS, потрібно налаштувати сервер для дозволу запитів з інших доменів, встановити заголовки Access-Control-Allow-Origin, Access-Control-Allow-Methods, тощо.
5. Що таке cookie?
- Cookie - це невеликий фрагмент даних, який сервер відправляє на браузер користувача, і браузер зберігає його та включає в кожен наступний запит до сервера. Вони використовуються для збереження інформації про сесію, налаштування і інші дані на боці клієнта.
6. Який максимальний розмір cookie?
- Максимальний розмір cookie обмежений браузером, зазвичай це близько 4096 байтів на кожний cookie, але це може варіюватися в залежності від браузера.
7. Що означає директива use strict?
8. Чим JS відрізняється під час роботи на front-end і back-end?
 - JavaScript на фронтенді (в браузері) використовується для взаємодії з користувачем і маніпуляції вмістом сторінки. На бекенді (на стороні сервера), JavaScript може використовуватися для розробки серверних додатків, обробки запитів, зберігання даних, тощо.
9. Що таке статична і динамічна типізації?
 - Статична типізація передбачає, що типи змінних визначаються під час компіляції і не можуть змінюватися під час виконання. Динамічна типізація дозволяє змінювати типи змінних під час виконання програми.
10. Як клієнт взаємодіє із сервером?
 - Клієнт взаємодіє з сервером, відправляючи HTTP-запити (наприклад, GET або POST) і отримуючи HTTP-відповіді. Взаємодія може включати передачу даних, завантаження сторінок, виконання запитів API, отримання ресурсів і багато іншого.
11. Що таке REST?
 - REST (Representational State Transfer) - це архітектурний стиль для розробки веб-сервісів, який використовує HTTP-методи (GET, POST, PUT, DELETE) для взаємодії з ресурсами через їхні URI. REST вимагає, щоб взаємодія була безстанційною і зберігала стан серверу на стороні клієнта.
12. Поясніть поняття мутабельність / іммутабельність? Які типи є мутабельними й навпаки?
 - Мутабельність вказує на можливість зміни об'єктів після їхньої створення, тоді як іммутабельність вказує на незмінність об'єктів після створення. У JavaScript, наприклад, рядки є іммутабельними, а масиви - мутабельними.
13. Як шукати помилки в коді? Чи використовуєте дебагер?
 -  Пошук помилок в коді можна проводити шляхом відстеження помилкових повідомлень, використання відлагоджувачів (debugger) для аналізу стану програми в точці зупинки, а також використання інструментів розробки браузера, таких як консоль для відлагодження. Важливо також тестувати код і використовувати тести для виявлення помилок.
14. Яких відомих людей зі світу JS знаєте?
 - Brendan Eich: Створив JavaScript.
 - Douglas Crockford: Відомий експерт з JavaScript і автор "JavaScript: The Good Parts."
 - John Resig: Розробив бібліотеку jQuery.
 - Ryan Dahl: Створив платформу Node.js.
 - Kyle Simpson: Автор серії книг "You Don't Know JS".

### JS Core
15. Які існують типи даних у JS?
- Примітивні типи: Number, String, Boolean, Null, Undefined, Symbol (ES6), BigInt (ES11).
- Об'єктні типи: Object, Array, Function, Date, RegExp, інші користувацькі об'єкти.
16. Як перевірити, чи об’єкт є масивом?
- Для перевірки, чи об'єкт є масивом, використовуйте метод Array.isArray(obj).
17. Як перевірити, чи число є скінченним?
- Щоб перевірити, чи число є скінченним, використовуйте isFinite(number).
18. Як перевірити, що змінна рівна NaN?
- Перевірку на NaN можна здійснити за допомогою isNaN(value).
19. Чим відрізняється поведінка isNaN() та Number.isNaN()?
- isNaN() перетворює аргумент в число перед перевіркою, тому може давати неправильний результат для нечислових значень, а Number.isNaN() перевіряє точно, чи значення є NaN.
20. Порівняйте ключові слова var, let, const.
- var - має функціональну область видимості і може бути змінено після оголошення;
- let - обмежена блоковою областю видимості і може бути змінено;
- const - обмежена блоковою областю видимості і не може бути переприсвоєна, але об'єкти, на які вона посилається, можуть змінюватися.
21. Що таке область видимості?
- Область видимості - це частина коду, де змінні або функції доступні для використання. В JavaScript області видимості визначаються за допомогою блоків коду, функцій і об'єктів.
22. Що таке деструктуризація?
- Деструктуризація - це спосіб отримання окремих значень з об'єкта або масиву і присвоєння їх змінним, за допомогою синтаксису, схожого на внесення.
23. Для чого призначені методи setTimeout і setInterval?
- setTimeout використовується для виконання функції після зазначеного проміжку часу, а setInterval - для виконання функції через регулярні інтервали часу.
24. Порівняйте підходи роботи з асинхронним кодом: сallbacks vs promises vs async/await.
- Колбеки (Callbacks):
  1. Це стандартний спосіб обробки асинхронності в JavaScript до появи більш сучасних підходів.
  2. Колбеки - це функції, які передаються як аргументи і викликаються після завершення асинхронної операції.
  3. Може виникнути "callback hell", коли багато асинхронних операцій вкладені одна в одну, що робить код важким для розуміння та обслуговування.

- Promises:
  1. Promises вводять концепцію об'єкта Promise, який представляє результат асинхронної операції, яка може бути успішною або невдалим.
  2. Це полегшує читання та обробку асинхронного коду і дозволяє уникнути "callback hell".
  3. Promise може бути в стані "виконано" (resolved) або "відхилено" (rejected), і можна приєднувати колбеки для обробки кожного з цих станів.

- async/await:
  1. async/await - це синтаксичний цукор над promises, який робить асинхронний код більш читабельним і схожим на синхронний код.
  2. async визначає функцію, яка повертає promises автоматично.
  3. await використовується в середині функції async для очікування завершення promises та повернення її результату.

25. Чи можна записувати нові властивості / функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?
- Так, можна записувати нові властивості / методи в прототипи стандартних класів. Проте це рекомендується робити обережно, оскільки це може призвести до конфліктів і непередбачених наслідків. Краще використовувати об'єкт, який наслідує від стандартного класу, і додавати властивості / методи до нього.
26. Назвіть методи масивів, які пам’ятаєте, і скажіть, для чого вони потрібні.
- push(): Додає елемент на кінець масиву.
- pop(): Видаляє останній елемент з масиву.
- shift(): Видаляє перший елемент з масиву.
- unshift(): Додає елемент на початок масиву.
- concat(): Об'єднує два масиви в новий масив.
- slice(): Повертає підмасив на основі вказаних індексів.
- forEach(): Виконує функцію для кожного елемента масиву.
- map(): Створює новий масив на основі результатів функції для кожного елемента.
- filter(): Створює новий масив, який містить елементи, які задовольняють умову.
- reduce(): Зменшує масив до одного значення за допомогою функції.
27. Які перебираючі методи масиву знаєте? У чому їхня відмінність?
 - forEach(): Виконує функцію для кожного елемента, не створюючи нового масиву.
 - map(): Створює новий масив, застосовуючи функцію до кожного елемента.
 - filter(): Створює новий масив з елементами, які відповідають умові.
 - reduce(): Обчислює одне значення за допомогою функції, яка накопичує результати обробки елементів масиву.
 - every(): Перевіряє, чи всі елементи масиву відповідають заданій умові і повертає булеве значення (true або false).
 - some(): Перевіряє, чи хоча б один елемент масиву відповідає заданій умові і повертає булеве значення (true або false).
 - find(): Знаходить перший елемент, який відповідає заданій умові.

findIndex(): Знаходить індекс першого елемента, який відповідає заданій умові.
28. Як працюють оператори присвоєння / порівняння / рядкові / арифметичні / бітові тощо?
- Оператори присвоєння (=, +=, -= тощо) встановлюють значення змінних.
- Оператори порівняння (==, ===, !=, !==, <, >, <=, >=) порівнюють значення.
- Оператори рядкові (+ для об'єднання рядків) виконують операції з рядками.
- Оператори арифметичні (+, -, *, /, %) виконують математичні операції.
- Оператори бітові (&, |, ^, <<, >>) працюють з бітами чисел.
29. Опишіть призначення і принципи роботи з колекціями Map і Set.
- Map - це колекція ключ-значення, де ключі можуть бути будь-якого типу, а Set - це колекція унікальних значень без повторень. Map і Set забезпечують швидкий доступ до даних і можуть використовуватися для зберігання та управління даними.
30. Що означає глибока (deep) та поверхнева (shallow) копія об’єкта? Як зробити кожну з них?
- Глибока копія об'єкта створює новий об'єкт, який копіює всі значення об'єкта та всі значення вкладених об'єктів та масивів, рекурсивно. Поверхнева копія створює новий об'єкт, але посилається на ті ж самі вкладені об'єкти та масиви. Глибоку копію можна створити рекурсивно, обходячи об'єкт і копіюючи його вміст, а поверхневу копію можна створити за допомогою Object.assign() або оператора деструктуризації.

### Функції
31. Яка різниця між декларацією функції (function declaration) та функціональним виразом (function expression)?
- Декларація функції (function declaration) оголошує функцію з іменем, яка може бути викликана до її оголошення. Її оголошення піднімається вгору (hoisted).
  ```
  function add(a, b) {
  return a + b;
  }
  ```

- Функціональний вираз (function expression) створює функцію, присвоюючи її змінній або виразу. Функцію можна викликати тільки після її оголошення.

    ```
  const add = function(a, b) {
   return a + b;
  };
  ```
32. Що таке анонімна функція?
 - Анонімна функція - це функція без імені. Вона може бути оголошена як функція-вираз, і її можна викликати за допомогою змінної, до якої вона присвоєна.

33. Розкажіть про стрілкові функції (arrow function). В чому полягають відмінності стрілкових функцій від звичайних?
- Стрілкові функції (arrow functions) - це спрощений синтаксис для оголошення функцій у JavaScript.
- Основні відмінності:
  1. Стрілкові функції не мають власного контексту (this) і беруть його з оточуючого коду.
  2. Вони коротші та зручніші для написання.
34. Що таке і для чого використовують IIFE (Immediately Invoked Function Expression)?
- IIFE (Immediately Invoked Function Expression) - це функціональний вираз, який виконується негайно після оголошення. Вони зазвичай використовуються для створення локального області видимості для змінних і уникнення конфлікту імен.
```
(function() {
  // Код тут
})();

```
35. Що таке hoisting, як він працює для змінних і функцій?
- Hoisting - це механізм в JavaScript, за допомогою якого оголошення змінних і функцій піднімаються вгору до початку виконання коду. Змінні можуть бути оголошені після використання, але функції можуть бути викликані перед їхнім оголошенням.
36. Що таке замикання (closure) і які сценарії його використання?
- Замикання (closure) - це функція, яка має доступ до змінних зі свого зовнішнього лексичного середовища, навіть після завершення виконання цього середовища. Замикання дозволяє зберігати стан і інкапсулювати логіку.
37. Як ви розумієте замикання? Що буде виведено в консолі в цьому випадку?
  ```
   var f = function() {
     console.log(1);
   }

    var execute = function(f) {
      setTimeout(f, 1000);
    }

    execute(f);

     f = function() {
      console.log(2);
    }
  ```
  
- В замиканні функція "замикана" на своєму лексичному середовищі, і вона може звертатися до змінних, які були доступні в момент її створення.
- В консолі 1

38. Що таке рекурсія?
- Рекурсія - це техніка програмування, коли функція викликає сама себе для розв'язання певної задачі. Рекурсія може бути простою (рекурсивні виклики функції) або складною (рекурсивні виклики функції з умовами виходу). Вона часто використовується для розв'язання завдань, які можуть бути поділені на більше простих підзадач.
39. Що означає ключове слово this?
- Ключове слово this - це спеціальна змінна в контексті функції, яка вказує на об'єкт, з яким викликана функція пов'язана. this може змінюватися залежно від того, як функція викликана: як метод об'єкта, як глобальна функція тощо.
40. Що таке втрата контексту, коли відбувається і як їй запобігти?
- Втрата контексту відбувається, коли функція втрачає посилання на об'єкт, з яким вона пов'язана. Це може статися при передачі функції як колбека, використанні setTimeout, а також при використанні функцій в обробниках подій чи внутрішніх функціях.
41. Методи функцій bind / call / apply — навіщо і в чому різниця?
 - bind(): Створює нову функцію, де this завжди вказує на певний об'єкт, але не викликає функцію негайно. Замість цього повертає функцію, яку можна викликати пізніше.
   ```
     const boundFunc = originalFunc.bind(context);
    ```
  - call(): Викликає функцію з певним значенням this і переданими окремо аргументами.
    ```
      originalFunc.call(context, arg1, arg2, ...);
    ```
  - apply(): Схожий на call, але аргументи передаються у вигляді масиву.
    ```
     originalFunc.apply(context, [arg1, arg2, ...]);
    ```
### Front-end
42. Що таке DOM?

43. Порівняйте атрибути підключення скрипту async і defer в HTML-документі.

44. Яка різниця між властивостями HTML-елементів innerHTML і innerText?

45. Опишіть процес спливання (bubbling) подій у DOM.

46. Як зупинити спливання (bubbling) події?

47. Як зупинити дефолтну обробку події?

48.Чому дорівнює this в обробнику подій (event handler)?

49. Що таке LocalStorage і SessionStorage? Який максимальний розмір LocalStorage?

50. Як отримати висоту блоку? Його положення щодо меж документа?

51. Що таке webpack?

52. Чим відрізняється dev-збірка від prod?

### Верстка
53. Що таке блокова модель CSS?

54. Які способи центрування блокового контенту по горизонталі та вертикалі знаєте?

55. Які підходи у верстці вам відомі (float, flex, grid, etc)?

56. Як зробити додаток responsive?

57. Які є принципи семантичної верстки?

58. Навіщо потрібні префікси для деяких CSS-властивостей (-webkit-, -moz- тощо)?

59. Як спростити написання кросбраузерних стилів?

60. Практичне завдання: прокоментувати та виправити приклад поганого CSS або HTML.

61. Що таке CSS-препроцесори? З якими працювали? Що нового вони приносять у стандартний CSS?

### React
62. Чи працювали з класовими компонентами? У чому їхня особливість?

63. Які дані краще зберігати в стані компонента, а які передавати через пропси? Наведіть приклад.

64.Чи ознайомлені з хуками? У чому їхні переваги? Чи доводилося робити свої і з якою метою?

65.Чи ознайомлені з фрагментами та порталами? Навіщо вони потрібні?

66. Коли й для чого використовують рефи?

67. Які ви знаєте методи життєвого циклу компонента?

68. В якому методі життєвого циклу компонента краще робити запити на сервер? Чому?

69. В якому методі життєвого циклу компонента краще робити підписку і відписку від лістенера? Чому? Навіщо відписуватися?

70. Чи був досвід роботи з контекстом? Коли його варто використовувати?

71. У чому особливість PureComponent?

72. Чи працював з мемоізованими селекторами (memoized selectors)? Для чого їх використовують і який принцип роботи?

73. У чому бачите переваги бібліотеки React?

74. Чому бібліотека React швидка? Що таке Virtual DOM і Shadow DOM?

75. Навіщо в списках ключі? Чи можна робити ключами індекси елементів масиву? Коли це виправдано?

76. В чому основна ідея Redux?

77. Робота зі стилями в React.

78. React — це бібліотека чи фреймворк? Яка різниця між цими двома поняттями.

79. Чи можна використовувати jQuery разом з React? Чому так / ні?

80. Що таке codemod?

81. Чи доводилося налаштовувати проєкт React з нуля? За допомогою яких інструментів ви це робили?

82. Перерахуйте всі бібліотеки, які використовували у зв’язці з React.

83. Що найскладніше доводилося реалізовувати за допомогою React?

### Back-end
84. Що таке REPL?

85. Що таке streams в Node.js?

86. Що таке middleware?

87. Для чого використовують функцію setImmediate?

88. Навіщо потрібен app.param() в express?

89. Що таке token based authentication?

### Бази даних
90. Напишіть простий запит для обчислення трьох авторів, у яких найбільше книг.

91. Напишіть запит, який вибирає останні три коментарі для конкретного користувача для двох таблиць: коментарі та користувачі.

92. Спроєктуйте просту схему бази даних для бібліотеки.

93. Для чого використовують SQL-оператор HAVING?

94. Навіщо використовують SQL-оператор LEFT JOIN?

95. Чим відрізняється embed- від reference-зв’язку в MongoDB?

96. В одному проєкті програмісти зберігають дані в MongoDB-колекції коментарів, використовуючи такі типи даних (дивіться нижче). Що поганого в цьому рішенні?
```
id: ObjectID
text: string
author_id: string
created_at: Date
```
97. У проєкті знадобилося внести зміни в структуру таблиць, додати кілька полів і індекси. Як програмісти будуть робити це на продакшені?

### Інструменти
98. Щоразу, коли ви робите pull, чомусь трапляється конфлікт в останньому рядку в усіх файлах, які ви редагували. Що відбувається?

99. Що робить команда git fetch?

100. Які git hygiene підходи ви знаєте?

101.Що таке CI/CD? Для чого це потрібно?
