# JavaScript_Interview_Questions
## Junior
### Загальні
1. Які методи HTTP-запитів ви знаєте? 
- HTTP (Hypertext Transfer Protocol) має кілька методів запитів, основні з них:

  1.  GET: Використовується для отримання даних з сервера.
  2. POST: Використовується для надсилання даних на сервер для створення нового ресурсу.
  3. PUT: Використовується для оновлення існуючого ресурсу на сервері.
  4. DELETE: Використовується для видалення ресурсу на сервері.
  5. HEAD: Схожий на GET, але повертає лише заголовки без тіла відповіді.
  6. OPTIONS: Використовується для отримання інформації про можливі методи та параметри ресурсу.

2. Які версії HTTP-протоколу вам відомі?
- HTTP/1.0
- HTTP/1.1
- HTTP/2
- HTTP/3
3. Які знаєте коди відповіді (стану) HTTP?
- 200 OK: Успішний запит.
- 201 Created: Ресурс успішно створений.
- 204 No Content: Запит виконаний, але немає даних для передачі.
- 400 Bad Request: Помилка у запиті від клієнта.
- 401 Unauthorized: Вимагається автентифікація для доступу.
- 403 Forbidden: Доступ заборонено через обмеження сервера.
- 404 Not Found: Ресурс не знайдено.
- 500 Internal Server Error: Внутрішня помилка сервера.
4. Що таке Cross-Origin Resource Sharing? Як усунути проблеми з CORS?
- Cross-Origin Resource Sharing (CORS) - це механізм безпеки в браузерах, який контролює доступ клієнта до ресурсів на іншому домені (орієнтований на джерело). Щоб усунути проблеми з CORS, потрібно налаштувати сервер для дозволу запитів з інших доменів, встановити заголовки Access-Control-Allow-Origin, Access-Control-Allow-Methods, тощо.
5. Що таке cookie?
- Cookie - це невеликий фрагмент даних, який сервер відправляє на браузер користувача, і браузер зберігає його та включає в кожен наступний запит до сервера. Вони використовуються для збереження інформації про сесію, налаштування і інші дані на боці клієнта.
6. Який максимальний розмір cookie?
- Максимальний розмір cookie обмежений браузером, зазвичай це близько 4096 байтів на кожний cookie, але це може варіюватися в залежності від браузера.
7. Що означає директива use strict?
8. Чим JS відрізняється під час роботи на front-end і back-end?
 - JavaScript на фронтенді (в браузері) використовується для взаємодії з користувачем і маніпуляції вмістом сторінки. На бекенді (на стороні сервера), JavaScript може використовуватися для розробки серверних додатків, обробки запитів, зберігання даних, тощо.
9. Що таке статична і динамічна типізації?
 - Статична типізація передбачає, що типи змінних визначаються під час компіляції і не можуть змінюватися під час виконання. Динамічна типізація дозволяє змінювати типи змінних під час виконання програми.
10. Як клієнт взаємодіє із сервером?
 - Клієнт взаємодіє з сервером, відправляючи HTTP-запити (наприклад, GET або POST) і отримуючи HTTP-відповіді. Взаємодія може включати передачу даних, завантаження сторінок, виконання запитів API, отримання ресурсів і багато іншого.
11. Що таке REST?
 - REST (Representational State Transfer) - це архітектурний стиль для розробки веб-сервісів, який використовує HTTP-методи (GET, POST, PUT, DELETE) для взаємодії з ресурсами через їхні URI. REST вимагає, щоб взаємодія була безстанційною і зберігала стан серверу на стороні клієнта.
12. Поясніть поняття мутабельність / іммутабельність? Які типи є мутабельними й навпаки?
 - Мутабельність вказує на можливість зміни об'єктів після їхньої створення, тоді як іммутабельність вказує на незмінність об'єктів після створення. У JavaScript, наприклад, рядки є іммутабельними, а масиви - мутабельними.
13. Як шукати помилки в коді? Чи використовуєте дебагер?
 -  Пошук помилок в коді можна проводити шляхом відстеження помилкових повідомлень, використання відлагоджувачів (debugger) для аналізу стану програми в точці зупинки, а також використання інструментів розробки браузера, таких як консоль для відлагодження. Важливо також тестувати код і використовувати тести для виявлення помилок.
14. Яких відомих людей зі світу JS знаєте?
 - Brendan Eich: Створив JavaScript.
 - Douglas Crockford: Відомий експерт з JavaScript і автор "JavaScript: The Good Parts."
 - John Resig: Розробив бібліотеку jQuery.
 - Ryan Dahl: Створив платформу Node.js.
 - Kyle Simpson: Автор серії книг "You Don't Know JS".

### JS Core
15. Які існують типи даних у JS?
- Примітивні типи: Number, String, Boolean, Null, Undefined, Symbol (ES6), BigInt (ES11).
- Об'єктні типи: Object, Array, Function, Date, RegExp, інші користувацькі об'єкти.
16. Як перевірити, чи об’єкт є масивом?
- Для перевірки, чи об'єкт є масивом, використовуйте метод Array.isArray(obj).
17. Як перевірити, чи число є скінченним?
- Щоб перевірити, чи число є скінченним, використовуйте isFinite(number).
18. Як перевірити, що змінна рівна NaN?
- Перевірку на NaN можна здійснити за допомогою isNaN(value).
19. Чим відрізняється поведінка isNaN() та Number.isNaN()?
- isNaN() перетворює аргумент в число перед перевіркою, тому може давати неправильний результат для нечислових значень, а Number.isNaN() перевіряє точно, чи значення є NaN.
20. Порівняйте ключові слова var, let, const.
- var - має функціональну область видимості і може бути змінено після оголошення;
- let - обмежена блоковою областю видимості і може бути змінено;
- const - обмежена блоковою областю видимості і не може бути переприсвоєна, але об'єкти, на які вона посилається, можуть змінюватися.
21. Що таке область видимості?
- Область видимості - це частина коду, де змінні або функції доступні для використання. В JavaScript області видимості визначаються за допомогою блоків коду, функцій і об'єктів.
22. Що таке деструктуризація?
- Деструктуризація - це спосіб отримання окремих значень з об'єкта або масиву і присвоєння їх змінним, за допомогою синтаксису, схожого на внесення.
23. Для чого призначені методи setTimeout і setInterval?
- setTimeout використовується для виконання функції після зазначеного проміжку часу, а setInterval - для виконання функції через регулярні інтервали часу.
24. Порівняйте підходи роботи з асинхронним кодом: сallbacks vs promises vs async/await.
- Колбеки (Callbacks):
  1. Це стандартний спосіб обробки асинхронності в JavaScript до появи більш сучасних підходів.
  2. Колбеки - це функції, які передаються як аргументи і викликаються після завершення асинхронної операції.
  3. Може виникнути "callback hell", коли багато асинхронних операцій вкладені одна в одну, що робить код важким для розуміння та обслуговування.

- Promises:
  1. Promises вводять концепцію об'єкта Promise, який представляє результат асинхронної операції, яка може бути успішною або невдалим.
  2. Це полегшує читання та обробку асинхронного коду і дозволяє уникнути "callback hell".
  3. Promise може бути в стані "виконано" (resolved) або "відхилено" (rejected), і можна приєднувати колбеки для обробки кожного з цих станів.

- async/await:
  1. async/await - це синтаксичний цукор над promises, який робить асинхронний код більш читабельним і схожим на синхронний код.
  2. async визначає функцію, яка повертає promises автоматично.
  3. await використовується в середині функції async для очікування завершення promises та повернення її результату.

25. Чи можна записувати нові властивості / функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?
- Так, можна записувати нові властивості / методи в прототипи стандартних класів. Проте це рекомендується робити обережно, оскільки це може призвести до конфліктів і непередбачених наслідків. Краще використовувати об'єкт, який наслідує від стандартного класу, і додавати властивості / методи до нього.
26. Назвіть методи масивів, які пам’ятаєте, і скажіть, для чого вони потрібні.
- push(): Додає елемент на кінець масиву.
- pop(): Видаляє останній елемент з масиву.
- shift(): Видаляє перший елемент з масиву.
- unshift(): Додає елемент на початок масиву.
- concat(): Об'єднує два масиви в новий масив.
- slice(): Повертає підмасив на основі вказаних індексів.
- forEach(): Виконує функцію для кожного елемента масиву.
- map(): Створює новий масив на основі результатів функції для кожного елемента.
- filter(): Створює новий масив, який містить елементи, які задовольняють умову.
- reduce(): Зменшує масив до одного значення за допомогою функції.
27. Які перебираючі методи масиву знаєте? У чому їхня відмінність?
 - forEach(): Виконує функцію для кожного елемента, не створюючи нового масиву.
 - map(): Створює новий масив, застосовуючи функцію до кожного елемента.
 - filter(): Створює новий масив з елементами, які відповідають умові.
 - reduce(): Обчислює одне значення за допомогою функції, яка накопичує результати обробки елементів масиву.
 - every(): Перевіряє, чи всі елементи масиву відповідають заданій умові і повертає булеве значення (true або false).
 - some(): Перевіряє, чи хоча б один елемент масиву відповідає заданій умові і повертає булеве значення (true або false).
 - find(): Знаходить перший елемент, який відповідає заданій умові.

findIndex(): Знаходить індекс першого елемента, який відповідає заданій умові.
28. Як працюють оператори присвоєння / порівняння / рядкові / арифметичні / бітові тощо?
- Оператори присвоєння (=, +=, -= тощо) встановлюють значення змінних.
- Оператори порівняння (==, ===, !=, !==, <, >, <=, >=) порівнюють значення.
- Оператори рядкові (+ для об'єднання рядків) виконують операції з рядками.
- Оператори арифметичні (+, -, *, /, %) виконують математичні операції.
- Оператори бітові (&, |, ^, <<, >>) працюють з бітами чисел.
29. Опишіть призначення і принципи роботи з колекціями Map і Set.
- Map - це колекція ключ-значення, де ключі можуть бути будь-якого типу, а Set - це колекція унікальних значень без повторень. Map і Set забезпечують швидкий доступ до даних і можуть використовуватися для зберігання та управління даними.
30. Що означає глибока (deep) та поверхнева (shallow) копія об’єкта? Як зробити кожну з них?
- Глибока копія об'єкта створює новий об'єкт, який копіює всі значення об'єкта та всі значення вкладених об'єктів та масивів, рекурсивно. Поверхнева копія створює новий об'єкт, але посилається на ті ж самі вкладені об'єкти та масиви. Глибоку копію можна створити рекурсивно, обходячи об'єкт і копіюючи його вміст, а поверхневу копію можна створити за допомогою Object.assign() або оператора деструктуризації.

### Функції
31. Яка різниця між декларацією функції (function declaration) та функціональним виразом (function expression)?
- Декларація функції (function declaration) оголошує функцію з іменем, яка може бути викликана до її оголошення. Її оголошення піднімається вгору (hoisted).
  ```
  function add(a, b) {
  return a + b;
  }
  ```

- Функціональний вираз (function expression) створює функцію, присвоюючи її змінній або виразу. Функцію можна викликати тільки після її оголошення.

    ```
  const add = function(a, b) {
   return a + b;
  };
  ```
32. Що таке анонімна функція?
 - Анонімна функція - це функція без імені. Вона може бути оголошена як функція-вираз, і її можна викликати за допомогою змінної, до якої вона присвоєна.

33. Розкажіть про стрілкові функції (arrow function). В чому полягають відмінності стрілкових функцій від звичайних?
- Стрілкові функції (arrow functions) - це спрощений синтаксис для оголошення функцій у JavaScript.
- Основні відмінності:
  1. Стрілкові функції не мають власного контексту (this) і беруть його з оточуючого коду.
  2. Вони коротші та зручніші для написання.
34. Що таке і для чого використовують IIFE (Immediately Invoked Function Expression)?
- IIFE (Immediately Invoked Function Expression) - це функціональний вираз, який виконується негайно після оголошення. Вони зазвичай використовуються для створення локального області видимості для змінних і уникнення конфлікту імен.
```
(function() {
  // Код тут
})();

```
35. Що таке hoisting, як він працює для змінних і функцій?
- Hoisting - це механізм в JavaScript, за допомогою якого оголошення змінних і функцій піднімаються вгору до початку виконання коду. Змінні можуть бути оголошені після використання, але функції можуть бути викликані перед їхнім оголошенням.
36. Що таке замикання (closure) і які сценарії його використання?
- Замикання (closure) - це функція, яка має доступ до змінних зі свого зовнішнього лексичного середовища, навіть після завершення виконання цього середовища. Замикання дозволяє зберігати стан і інкапсулювати логіку.
37. Як ви розумієте замикання? Що буде виведено в консолі в цьому випадку?
  ```
   var f = function() {
     console.log(1);
   }

    var execute = function(f) {
      setTimeout(f, 1000);
    }

    execute(f);

     f = function() {
      console.log(2);
    }
  ```
  
- В замиканні функція "замикана" на своєму лексичному середовищі, і вона може звертатися до змінних, які були доступні в момент її створення.
- В консолі 1

38. Що таке рекурсія?
- Рекурсія - це техніка програмування, коли функція викликає сама себе для розв'язання певної задачі. Рекурсія може бути простою (рекурсивні виклики функції) або складною (рекурсивні виклики функції з умовами виходу). Вона часто використовується для розв'язання завдань, які можуть бути поділені на більше простих підзадач.
39. Що означає ключове слово this?
- Ключове слово this - це спеціальна змінна в контексті функції, яка вказує на об'єкт, з яким викликана функція пов'язана. this може змінюватися залежно від того, як функція викликана: як метод об'єкта, як глобальна функція тощо.
40. Що таке втрата контексту, коли відбувається і як їй запобігти?
- Втрата контексту відбувається, коли функція втрачає посилання на об'єкт, з яким вона пов'язана. Це може статися при передачі функції як колбека, використанні setTimeout, а також при використанні функцій в обробниках подій чи внутрішніх функціях.
41. Методи функцій bind / call / apply — навіщо і в чому різниця?
 - bind(): Створює нову функцію, де this завжди вказує на певний об'єкт, але не викликає функцію негайно. Замість цього повертає функцію, яку можна викликати пізніше.
   ```
     const boundFunc = originalFunc.bind(context);
    ```
  - call(): Викликає функцію з певним значенням this і переданими окремо аргументами.
    ```
      originalFunc.call(context, arg1, arg2, ...);
    ```
  - apply(): Схожий на call, але аргументи передаються у вигляді масиву.
    ```
     originalFunc.apply(context, [arg1, arg2, ...]);
    ```
### Front-end
42. Що таке DOM?
- DOM (Document Object Model) - це структура, яка представляє інтерактивний документ веб-сторінки, яка може бути змінена за допомогою JavaScript. Вона створює ієрархію об'єктів, які представляють кожен елемент HTML-сторінки, що дозволяє програмно взаємодіяти з цими елементами.
43. Порівняйте атрибути підключення скрипту async і defer в HTML-документі.
- async: Скрипт завантажується асинхронно, і виконується, як тільки завантажиться, незалежно від того, як завантажується решта сторінки.
- defer: Скрипт завантажується асинхронно, але виконується тільки після завантаження сторінки. Порядок виконання скриптів зберігається.
44. Яка різниця між властивостями HTML-елементів innerHTML і innerText?
- innerHTML: Зчитує або встановлює HTML-код вмісту елемента, включаючи теги.
- innerText: Зчитує або встановлює тільки текстовий вміст елемента, ігноруючи HTML-теги.
45. Опишіть процес спливання (bubbling) подій у DOM.
- Спливання (bubbling) подій у DOM - це процес, коли подія, спочатку спрацювавши на найглибшому вкладеному елементі, поширюється вгору по ієрархії батьківських елементів до кореня документа (body або html). Це дозволяє обробникам подій батьківських елементів реагувати на ту саму подію.
46. Як зупинити спливання (bubbling) події?
- Метод stopPropagation() може бути використаний в обробнику події для зупинки подальшого спливання події до вищих елементів.
47. Як зупинити дефолтну обробку події?
- Метод preventDefault() може бути використаний в обробнику події для зупинки стандартної дії, яка пов'язана з цією подією. Наприклад, відмінити перехід за посиланням в <a>.
48.Чому дорівнює this в обробнику подій (event handler)?
- this в обробнику подій (event handler) - це посилання на об'єкт, до якого відноситься обробник події, тобто на елемент DOM, до якого прикріплений цей обробник. Він може бути корисним для доступу до контексту об'єкта, до якого прив'язана подія.
49. Що таке LocalStorage і SessionStorage? Який максимальний розмір LocalStorage?
- LocalStorage і SessionStorage - це механізми для зберігання даних на стороні клієнта (браузера). Вони схожі за функціональністю, але відрізняються тим, що:
- LocalStorage зберігає дані без обмеження строку життя, поки їх не видалити вручну або не очистити кеш браузера.
- SessionStorage зберігає дані лише протягом одного сеансу браузера, тобто вони будуть видалені після закриття вкладки або вікна браузера.
- Максимальний розмір LocalStorage зазвичай становить 5-10 МБ.
50. Як отримати висоту блоку? Його положення щодо меж документа?
- Висоту блоку можна отримати за допомогою властивості offsetHeight або методу clientHeight.
- Положення блоку відносно меж документа можна отримати за допомогою властивості offsetTop.
51. Що таке webpack?
- Webpack - це інструмент для збірки (bundling) і управління залежностями JavaScript-додатків. Він дозволяє об'єднувати багато файлів JavaScript в один або декілька файлів для оптимізації завантаження додатка в браузері.
52. Чим відрізняється dev-збірка від prod?
- dev-збірка (розробницька збірка) призначена для розробки і зазвичай не оптимізована. Вона може містити недооптимізований код, додаткову інформацію для налагодження і не бути мініфікованою.
- prod (продакшн-збірка) призначена для продакшну і містить оптимізований, мініфікований код без додаткової інформації для налагодження. Вона зазвичай має менший розмір і завантажується швидше.
### Верстка
53. Що таке блокова модель CSS?
- Блокова модель CSS - це основний принцип організації елементів на веб-сторінці з використанням CSS. Вона визначає, як елементи відображаються на сторінці, включаючи розміри, відступи, рамки, поля та інші характеристики. Блокова модель включає в себе властивості width, height, margin, padding, border, і деякі інші.
54. Які способи центрування блокового контенту по горизонталі та вертикалі знаєте?
- По горизонталі:
  1. text-align: center; для контейнера і display: inline-block; для самого блоку.
  2. margin: 0 auto; для блоку з фіксованою шириною.
  3. flexbox і justify-content: center; для контейнера.
  4. grid і justify-items: center; для контейнера.
- По вертикалі:
  1. position: relative; для контейнера і position: absolute; top: 50%; transform: translateY(-50%); для блоку.
  2. flexbox і align-items: center; для контейнера.
  3. grid і align-items: center; для контейнера.
55. Які підходи у верстці вам відомі (float, flex, grid, etc)?
- float: Застарілий метод, який використовується для розміщення елементів в струмину.
- flexbox: Гнучкий метод для розміщення елементів у великому контейнері, з багатьма можливостями розташування.
- grid: Розкладка елементів у таблиці з рядками і стовпцями.
- Ще існують методи відмінностей, такі як position, display, float тощо.
56. Як зробити додаток responsive?
- Робота додатка responsive передбачає, що додаток виглядає і працює добре на різних пристроях та розмірах екрану. Це досягається за допомогою резинового (fluid) дизайну, медіазапитів (media queries), і відповідних стилів для різних розмірів екрану.
57. Які є принципи семантичної верстки?
- Використання правильних HTML-тегів для правильного семантичного значення.
- Використання заголовків (<h1>, <h2> тощо) для ієрархії тексту.
- Використання списків (<ul>, <ol>) для переліків і табличних структур для таблиць.
- Використання атрибутів alt для зображень для покращення доступності.
- Завдання класів і id з обережністю і для явної ролі в CSS, і не для стилізації.

58. Навіщо потрібні префікси для деяких CSS-властивостей (-webkit-, -moz- тощо)?
- Префікси для CSS-властивостей (-webkit-, -moz- тощо) використовуються для забезпечення сумісності з різними браузерами, особливо при використанні експериментальних або нестандартних CSS-властивостей. Деякі браузери можуть потребувати префікси для властивостей, які ще не були стандартизовані.
59. Як спростити написання кросбраузерних стилів?
- Спрощення написання кросбраузерних стилів можна досягти за допомогою CSS-препроцесорів (наприклад, Sass або Less), які дозволяють використовувати змінні, мікси, і інші функції для зручності і перевикористання коду. Також важливо тестувати стилі на різних браузерах і використовувати плагіни для автоматичного вставлення вендорних префіксів.
60. Практичне завдання: прокоментувати та виправити приклад поганого CSS або HTML.
61. Що таке CSS-препроцесори? З якими працювали? Що нового вони приносять у стандартний CSS?
- CSS-препроцесори - це мови розширення CSS, які додають додаткові функції і можливості до звичайного CSS. Деякі з них включають Sass, Less і Stylus. Вони дозволяють використовувати змінні, мікси, умовні оператори і багато інших корисних функцій для покращення організації і підтримки коду. Препроцесори компілюються в звичайний CSS для використання в браузері.
### React
62. Чи працювали з класовими компонентами? У чому їхня особливість?
- Так, класові компоненти були попередньою основною способом написання компонентів у React до введення хуків.
63. Які дані краще зберігати в стані компонента, а які передавати через пропси? Наведіть приклад.
- Дані, які повинні змінюватися і впливати на відображення компонента, краще зберігати в стані компонента. Наприклад, введення користувача в формі або стан, який змінює відображення компонента.
- Дані, які залишаються сталими або передаються з батьківського компонента в дочірній, краще передавати через пропси.
64.Чи ознайомлені з хуками? У чому їхні переваги? Чи доводилося робити свої і з якою метою?
- Хуки (hooks) - це функції, які дозволяють використовувати функціональність React у функціональних компонентах. Вони вводяться у React з метою полегшення створення і керування станом, ефектами та іншими функціональностями компонентів. Їх переваги включають зручність, повторне використання, і більшу зрозумілість коду.
65.Чи ознайомлені з фрагментами та порталами? Навіщо вони потрібні?
- Фрагменти (<React.Fragment>) використовуються для об'єднання декількох дочірніх елементів без створення надмірних DOM вузлів.
- Портали (portals) дозволяють вставити дочірні елементи в інший DOM вузол, який може бути поза кореневим DOM елементом вашого додатка.
66. Коли й для чого використовують рефи?
- Рефи (refs) використовуються для доступу до реальних DOM елементів або екземплярів компонентів у React. Вони використовуються рідко і зазвичай в ситуаціях, коли інші підходи не підходять. Наприклад, для фокусування на певному полі вводу або виміру розміру DOM елементу.
67. Які ви знаєте методи життєвого циклу компонента?
- 
68. В якому методі життєвого циклу компонента краще робити запити на сервер? Чому?
- Запити на сервер краще робити в методі життєвого циклу componentDidMount. Це рекомендується, оскільки цей метод викликається після того, як компонент вперше рендериться і може бути використаний для ініціалізації даних. Також в цьому методі можна використовувати асинхронні запити до сервера, і це не блокуватиме рендеринг компонента.
69. В якому методі життєвого циклу компонента краще робити підписку і відписку від лістенера? Чому? Навіщо відписуватися?
- 
70. Чи був досвід роботи з контекстом? Коли його варто використовувати?

71. У чому особливість PureComponent?

72. Чи працював з мемоізованими селекторами (memoized selectors)? Для чого їх використовують і який принцип роботи?

73. У чому бачите переваги бібліотеки React?
- Переваги бібліотеки React включають в себе простоту використання, реактивний підхід до UI, велику активну спільноту та багато розширень і бібліотек для розробки.
74. Чому бібліотека React швидка? Що таке Virtual DOM і Shadow DOM?
- Бібліотека React швидка завдяки використанню Virtual DOM. Вона створює віртуальне представлення DOM структури і порівнює його з реальним DOM для ефективного визначення, які частини сторінки потребують оновлення. Shadow DOM - це технологія, яка дозволяє ізолювати CSS і JavaScript від інших частин сторінки, але вона не прямо пов'язана з React.
75. Навіщо в списках ключі? Чи можна робити ключами індекси елементів масиву? Коли це виправдано?

76. В чому основна ідея Redux?
- Redux - це бібліотека для управління станом додатку в React (і інших бібліотеках). Основна ідея - зберігати стан додатку в одному централізованому об'єкті (стор), який може бути змінений лише за допомогою дій (actions). Це спрощує управління станом, робить його передбачуваним і полегшує тестування.
77. Робота зі стилями в React.
- Робота зі стилями в React може включати в себе використання CSS модулів, CSS-in-JS бібліотек, inline-стилів і багато інших підходів. Зазвичай, рекомендується використовувати той підхід, який вам зручний і відповідає потребам вашого проєкту.
78. React — це бібліотека чи фреймворк? Яка різниця між цими двома поняттями.

79. Чи можна використовувати jQuery разом з React? Чому так / ні?

80. Що таке codemod?

81. Чи доводилося налаштовувати проєкт React з нуля? За допомогою яких інструментів ви це робили?

82. Перерахуйте всі бібліотеки, які використовували у зв’язці з React.

83. Що найскладніше доводилося реалізовувати за допомогою React?

### Back-end
84. Що таке REPL?

85. Що таке streams в Node.js?

86. Що таке middleware?

87. Для чого використовують функцію setImmediate?

88. Навіщо потрібен app.param() в express?

89. Що таке token based authentication?

### Бази даних
90. Напишіть простий запит для обчислення трьох авторів, у яких найбільше книг.

91. Напишіть запит, який вибирає останні три коментарі для конкретного користувача для двох таблиць: коментарі та користувачі.

92. Спроєктуйте просту схему бази даних для бібліотеки.

93. Для чого використовують SQL-оператор HAVING?

94. Навіщо використовують SQL-оператор LEFT JOIN?

95. Чим відрізняється embed- від reference-зв’язку в MongoDB?

96. В одному проєкті програмісти зберігають дані в MongoDB-колекції коментарів, використовуючи такі типи даних (дивіться нижче). Що поганого в цьому рішенні?
```
id: ObjectID
text: string
author_id: string
created_at: Date
```
97. У проєкті знадобилося внести зміни в структуру таблиць, додати кілька полів і індекси. Як програмісти будуть робити це на продакшені?

### Інструменти
98. Щоразу, коли ви робите pull, чомусь трапляється конфлікт в останньому рядку в усіх файлах, які ви редагували. Що відбувається?

99. Що робить команда git fetch?

100. Які git hygiene підходи ви знаєте?

101.Що таке CI/CD? Для чого це потрібно?

## Middle
### Загальні
1. Розкажіть про піраміду тестування.

2. Які типи автоматизованих тестів випадала нагода писати? Які бібліотеки при цьому використовували? Яким інструментам віддаєте перевагу і чому?

3. Що таке unit-тести? Яке місце в піраміді тестування займають unit-тести?

4. Що таке code coverage? Чи обов’язкове 100% покриття тестами коду?

5. Як заборонити браузеру віддавати кеш на HTTP-запит?

6. Що таке XSS (Cross-Site Scripting)?

7. Розкажіть про патерни Observer, Pub / Sub. Яка між ними різниця? Наведіть приклади реалізації цих патернів у відомих фреймворках / бібліотеках / браузерних API.

8. З якою метою може бути використаний event listener події fetch self.addEventListener(’fetch’, event => {}) ?

9. Що таке Event loop і як він працює? Розкажіть про мікрозадачі та макрозадачі.

### JS Core
10. Які типи даних бувають у JavaScript? Який буде результат виконання [коду](https://carbon.now.sh/rDyOjpu0vvgvo8CdAvxr)?
```
let firstObj = { name: 'Hello' };

let secondObj = firstObj;

firstObj = { name: 'Bye' };

console.log(secondObj.name);
```

11. Що таке temporal dead zone?

12. Як працює boxing / unboxing у JavaScript?

13. У чому різниця між оператором in і методом hasOwnProperty?

14. Опишіть, за допомогою чого в JS реалізуються такі ООП-парадигми, як інкапсуляція, поліморфізм, абстракція?

15. Що таке прототип? Як працює прототипне наслідування в JS? Поясніть роботу [коду](https://carbon.now.sh/IhjDlxZwvH7rxq8JlXhO).
```
function Main () {}
Main.prototype = { protected: true };

const obj = new Main();
Main.prototype = { protected: false };

console.log('Object protection: ', obj.protected); 
```
16. Яка різниця між композицією та наслідуванням?

17. Чому не варто використовувати конструктори типу new String?

18. Розкажіть про базовий пристрій і механізм роботи Event loop.

19. Що таке записи (records) і кортежі (tuples)? Чим вони відрізняються від звичайних об’єктів?

20. Які відмінності в поведінці ES5 функції-конструктора та ES2015 класу?

21. Як реалізувати патерн «Модуль»?

22. Чому typeof null повертає object?

23. Що таке приведення (перетворення) типів у JS?

24. Що таке явне і неявне приведення (перетворення) типів даних у JS? Як відбувається перетворення типів у таких прикладах:
```
{}+[]+{}+[1]
!!"false" == !!"true"
['x'] == 'x'
```
25. Що таке Garbage Collector?

26. Опишіть основні принципи роботи «збирача сміття» у JS-рушіях (engines).

27. Опишіть призначення і принципи роботи з колекціями WeakMap і WeakSet? Чим вони відрізняються від колекцій Map і Set відповідно?

28. Чим відрізняється Observable від Promise?

29. Що таке Promise? Назвіть порядок виконання then і catch у ланцюжку.
```
Promise.resolve(10)
  .then(e => console.log(e)) // ??
  .then(e => Promise.resolve(e))
  .then(console.log) // ??
  .then(e => {
    if (!e) {
      throw 'Error caught';
    }
  })
  .catch(e => {
    console.log(e); // ??
    return new Error('New error');
  })
  .then(e => {
    console.log(e.message); // ??
  })
  .catch(e => {
    console.log(e.message); // ??
  });
  ```
30. Розкажіть про послідовне і паралельне виконання асинхронних функцій. У чому різниця між Promise.all () і Promise.allSettled ()?

31. Що таке дескриптори властивостей об’єктів? Розкажіть про їхнє практичне застосування.

32. Назвіть кілька способів створення незмінного об’єкта в JavaScript.

33. Як створити властивість в об’єкта, яку не можна буде змінити?

34. Навіщо потрібен конструктор Proxy? Наведіть приклад використання.

35. Що таке ArrayBuffer? У чому різниця між Uint32Array і Float32Array? Який результат виконання коду?
```
const uint32Array = new Uint32Array();
Array.isArray(uint32Array);
36.Яким буде результат порівняння?

const url = “HTTPs://xyz.com/path<to>page.html”;
encodeURI(url) == encodeURIComponent(url); 
37.Розкажіть про генератори та ітератори.
38.. Поясніть, що робить наведений код:

function * fn(num) {
  for (let i = 0; i < num; i += 1) {
    yield console.log(i);
  }
}
const loop = fn(5);
loop.next();
loop.next();
```
39.Розкажіть про тип даних Symbol і його практичне застосування. Як перевести число з 10-розрядної системи в 16(2,8)-розрядну систему числення?

###Функції
40.Поясніть, що означає currying. Наведіть приклад використання на практиці.
41.Наведіть приклад функції з мемоізацією. Коли варто застосовувати цю техніку?
42.Що таке чейнінг функцій? Напишіть приклад з використанням цього підходу.
43.У чому різниця між function і arrow function? Яким буде результат виконання коду?

const pluckDeep = key => obj => key.split('.').reduce((accum, key) => accum[key], obj)

const compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res)

const unfold = (f, seed) => {
  const go = (f, seed, acc) => {
    const res = f(seed)
    return res ? go(f, res[1], acc.concat([res[0]])) : acc
  }
  return go(f, seed, [])
}
Front-end
44.У чому принципова різниця між подіями mouseleave і mouseout?
45.У якому порядку обробляються призначені для користувача події в DOM (click, mouseover тощо)? FIFO чи LIFO?
46.Що таке Event bubbling та Event capturing?
47.Порівняйте методи об’єкта event stopPropagation та stopImmediateProparation.
48.Які є підходи оптимізації продуктивності вебсторінки?
49.Як реалізований механізм same-origin policy в браузері? На які браузерні API він поширюється?
50.Назвіть способи зберігання даних у браузері. Порівняйте їх.
51.Web worker’и. Опишіть особливості передачі даних між worker’ами та основним потоком, між розділеними worker’ами.
51.Що таке Transferable-об’єкти?
52.Розкажіть про способи оптимізації виконання ресурсомістких операцій JS для поліпшення продуктивності рендерингу контенту на сторінці.
53.Чому ResizeObserver викликає події зміни розміру до відтворення елемента, а не після?
54.Розкажіть, як ви розумієте Web Accessibility?
55.Опишіть алгоритм створення функціоналу, що забезпечує читання вмісту .txt-файлу при перетягуванні його з файлової системи у вікно браузера.
56.Що таке Virtual DOM?

## Senior
### Загальні
1. Розкажіть про функціональне програмування.

2. Що таке TDD (Test Driven Development) / BDD (Behavior Driven Development)?

3. Розкажіть детально про роботу HTTPS.

4. Який стек технологій можна обрати для реалізації клону якогось відомого проєкту і чому?

5. Є проєкт на старих технологіях, необхідно в нього вносити зміни. Як це зробити найкраще?

6. Якщо у кандидата є досвід роботи з кількома фреймворками: який будете використовувати для наступного проєкту? Які фактори будуть впливати на вибір?

7. Що таке V8 Engine?

### JS Core
8. Реалізація патерну Class Free OOP (HTTPs://observablehq.com/@bratter/class-free-oop).

9. Патерн async disposer (HTTPs://advancedweb.hu/what-is-the-async-disposer-pattern-in-javascript).

10. Використання регулярних виразів. Коли прийнятно / неприйнятно? Як вони працюють? Як можна зробити читабельним код?

### Front-end
11. Як браузер визначає, чи ми можемо спілкуватися між вкладками?

12. Що таке Content Security Policy?

13. Як уникнути завантаження кешованих файлів скриптів і стилів?

14. Що таке requestAnimationFrame?

15. Розкажіть про мікросервісну архітектуру Front-end App.

16. Що таке Shadow DOM?

17. Порівняйте nextElementSibling та nextSibling.

18. Які знаєте метрики вебсайту?

### Back-end
19. Порівняйте Common.js з AMD Modules та ES6 Imports.

20. Який фреймворк вибрали б для бекенду, чому?

21. Опишіть своїми словами, як працює OAuth v2.

22. Є проєкт з джерелами витоку пам’яті, як їх виявити, усунути та запобігти цьому в майбутньому?

23. Є проєкт з performance issues, як їх виявити, усунути та запобігти в майбутньому?

### Бази даних
24. Які альтернативні види баз даних використовуєте?

25. Що таке RDS і чому він іноді не підходить?

26. Що таке SQL Injections і як їх уникнути?

27. Чому для запитів у БД треба використовувати плейсхолдери?

28. Як спроєктувати кластер на MongoDB?

29. Для чого використовують MongoDB Aggregation framework?

30. Розкажіть про GraphQL.

### Інструменти
31. Чи можете описати суть методології git flow двома словами?

32. Що означає вимога робити squash commits під час rebase?

33. Яка ваша думка про альтернативні системи контролю версій (Version Control System)?

34. Які конвенції знаєте і використовуєте для git?

35. Розкажіть про свій досвід використання / впровадження СI/CD.

36. Потрібно налаштувати деплой проєкту на кілька середовищ. Розкажіть, як би ви побудували процес? Які інструменти використали б?
